{"meta":{"title":"l0ser","subtitle":null,"description":null,"author":null,"url":"http://zero-mk.github.io"},"pages":[{"title":"categories","date":"2018-11-20T12:52:13.000Z","updated":"2018-11-20T12:52:13.433Z","comments":true,"path":"categories/index.html","permalink":"http://zero-mk.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-20T12:52:04.000Z","updated":"2018-11-20T12:52:04.650Z","comments":true,"path":"tags/index.html","permalink":"http://zero-mk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python的zlib.crc32","slug":"crc32","date":"2019-01-01T14:47:13.000Z","updated":"2019-01-01T15:39:28.369Z","comments":true,"path":"2019/01/01/crc32/","link":"","permalink":"http://zero-mk.github.io/2019/01/01/crc32/","excerpt":"","text":"很多的ctf misc题可以用crc32碰撞解出来,就像gxnnctf2018的一道misc题,解压得到一堆压缩包,一个一个爆破很费时间,随便打开一个压缩包可以观察出,flag.txt只有三个字符,三个字符的crc32碰撞几乎是秒解 python的zlib库里就有crc32校验的模块: 123In [1]: import zlibIn [2]: hex(zlib.crc32(\"078\")&amp;0xffffffff)Out[2]: '0x632f2428' crc32爆破脚本: 12345678import zlibcrc32code = raw_input('crc32 : ')#这个脚本是爆破3位数字的,所以是xrange(0,100),其他的自己照葫芦画瓢for i in xrange(0,100): buf = str(i).rjust(3,'0') if zlib.crc32(buf) &amp; 0xffffffff == int(crc32code,16): print '[*]',buf 用来解上面题目: crc32_1 完善一下脚本批量解出每个压缩包的flag.txt的内容,发现对着ascii码都能转成可见字符,再base64解码就得到flag,在这里我就不放出来了,自己照葫芦画瓢","categories":[],"tags":[{"name":"ctf-misc","slug":"ctf-misc","permalink":"http://zero-mk.github.io/tags/ctf-misc/"}]},{"title":"pwntools的命令行工具pwn","slug":"pwntools-Command Line Tools","date":"2019-01-01T06:39:34.000Z","updated":"2019-01-01T06:45:35.265Z","comments":true,"path":"2019/01/01/pwntools-Command Line Tools/","link":"","permalink":"http://zero-mk.github.io/2019/01/01/pwntools-Command Line Tools/","excerpt":"","text":"注:我只是翻译(机翻加个人使用然后修正)玩玩的,可能会有错,看看就好,有错的地方请私信我:1565328054@qq.com十分感谢 Pwntools 附带了一些有用的命令行实用程序 pwnPwntools 命令行界面123usage: pwn [-h] &#123;asm,checksec,constgrep,cyclic,debug,disasm,disablenx,elfdiff,elfpatch,errno,hex,phd,pwnstrip,scramble,shellcraft,template,unhex,update&#125; ... 显示这个帮助信息，然后退出1-h, --help ### pwn asm (汇编器)123usage: pwn asm [-h] [-f &#123;raw,hex,string,elf&#125;] [-o file] [-c context] [-v AVOID] [-n] [-z] [-d] [-e ENCODER] [-i INFILE] [-r] [line [line ...]] 1line 要组装的代码行。 如果没有提供，请使用 stdin 1-h, --help 显示这个帮助信息，然后退出 1-f &#123;raw,hex,string,elf&#125;, --format &#123;raw,hex,string,elf&#125; 输出格式(对于 ttys，默认为十六进制，否则为原始类型) 1-o &lt;file&gt;, --output &lt;file&gt; 输出文件(默认为 stdout) 1-c &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125;, --context &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125; 指定生成的shellcode的 操作系统 / 架构 / 字节序(大端小端) / 位数 (默认是: linux/i386), 从: [‘16’, ‘32’, ‘64’, ‘android’, ‘cgc’, ‘freebsd’, ‘linux’, ‘windows’, ‘powerpc64’, ‘aarch64’, ‘sparc64’, ‘powerpc’, ‘mips64’, ‘msp430’, ‘thumb’, ‘amd64’, ‘sparc’, ‘alpha’, ‘s390’, ‘i386’, ‘m68k’, ‘mips’, ‘ia64’, ‘cris’, ‘vax’, ‘avr’, ‘arm’, ‘little’, ‘big’, ‘el’, ‘le’, ‘be’, ‘eb’]中选择 1-v &lt;avoid&gt;, --avoid &lt;avoid&gt; 对 shellcode 进行编码 (provided as hex; default: 000a) 1-n, --newline 将 shell 代码编码以避免换行 1-z, --zero 对 shell 代码进行编码，以避免NULL byte 1-d, --debug 使用GDB 调试 shellcode 1-e &lt;encoder&gt;, --encoder &lt;encoder&gt; 指定编码器 1-i &lt;infile&gt;, --infile &lt;infile&gt; 指定输入文件 1-r, --run 运行输出 pwn disasm (反汇编器)12usage: pwn disasm [-h] [-c arch_or_os] [-a address] [--color] [--no-color] [hex [hex ...]] 1hex Hex-string to disasemble. If none are supplied, then it uses stdin in non-hex mode. 1-h, --help 显示这个帮助信息，然后退出 1-c &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125;, --context &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125; 指定生成的shellcode的 操作系统 / 架构 / 字节序(大端小端) / 位数 (默认是: linux/i386), 从: [‘16’, ‘32’, ‘64’, ‘android’, ‘cgc’, ‘freebsd’, ‘linux’, ‘windows’, ‘powerpc64’, ‘aarch64’, ‘sparc64’, ‘powerpc’, ‘mips64’, ‘msp430’, ‘thumb’, ‘amd64’, ‘sparc’, ‘alpha’, ‘s390’, ‘i386’, ‘m68k’, ‘mips’, ‘ia64’, ‘cris’, ‘vax’, ‘avr’, ‘arm’, ‘little’, ‘big’, ‘el’, ‘le’, ‘be’, ‘eb’]中选择 1-a &lt;address&gt;, --address &lt;address&gt; 基址 1--color 彩色输出 1--no-color 禁用颜色输出 pwn checksec (检查elf安全机制)1usage: pwn checksec [-h] [--file [elf [elf ...]]] [elf [elf ...]] 1elf 要检查的文件 1-h, --help 显示这个帮助信息，然后退出 1--file &lt;elf&gt; 要检查的文件(是否与 checksec.sh 兼容) pwn cyclic (测溢出点)123usage: pwn cyclic [-h] [-a alphabet] [-n length] [-c context] [-l lookup_value] [count] 1count 要打印的字符数 1-h, --help 显示这个帮助信息，然后退出 1-a &lt;alphabet&gt;, --alphabet &lt;alphabet&gt; 循环模式中使用的字母表(默认为所有小写字母) 1-n &lt;length&gt;, --length &lt;length&gt; 指定子序列的大小 (defaults to 4).-c {16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb}, –context {16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb}指定生成的shellcode的 操作系统 / 架构 / 字节序(大端小端) / 位数 (默认是: linux/i386), 从: [‘16’, ‘32’, ‘64’, ‘android’, ‘cgc’, ‘freebsd’, ‘linux’, ‘windows’, ‘powerpc64’, ‘aarch64’, ‘sparc64’, ‘powerpc’, ‘mips64’, ‘msp430’, ‘thumb’, ‘amd64’, ‘sparc’, ‘alpha’, ‘s390’, ‘i386’, ‘m68k’, ‘mips’, ‘ia64’, ‘cris’, ‘vax’, ‘avr’, ‘arm’, ‘little’, ‘big’, ‘el’, ‘le’, ‘be’, ‘eb’]中选择 -l &lt;lookup_value&gt;, -o &lt;lookup_value&gt;, –offset &lt;lookup_value&gt;, –lookup &lt;lookup_value&gt;Do a lookup instead printing the alphabet pwn hex (数据转十六进制)1usage: pwn hex [-h] [data [data ...]] 1data 数据转换为十六进制 1-h, --help 显示这个帮助信息，然后退出 pwn unhex (解码十六进制)1usage: pwn unhex [-h] [hex [hex ...]] 1hex 要解码的十六进制字节 1-h, --help 显示这个帮助信息，然后退出 pwn update (更新pwntools)1usage: pwn update [-h] [--install] [--pre] 1-h, --help 显示这个帮助信息，然后退出 1--install 自动安装更新。 1--pre 检查预发行版本。 pwn phd (dump出efl的hex有点像xxd)123usage: pwn phd [-h] [-w WIDTH] [-l [HIGHLIGHT [HIGHLIGHT ...]]] [-s SKIP] [-c COUNT] [-o OFFSET] [--color [&#123;always,never,auto&#125;]] [file] 1file file 转换到 hex。 如果丢失，从 stdin 读取。 1-h, --help 显示这个帮助信息，然后退出 1-w &lt;width&gt;, --width &lt;width&gt; 每行字节数。 1-l &lt;highlight&gt;, --highlight &lt;highlight&gt; 要高亮的字节。 1-s &lt;skip&gt;, --skip &lt;skip&gt; 跳过多少字节。 1-c &lt;count&gt;, --count &lt;count&gt; 只显示这么多字节。 1-o &lt;offset&gt;, --offset &lt;offset&gt; 左栏中的地址从这个地址开始。 1--color &#123;always,never,auto&#125; 使输出着色。 当”auto”输出正好是着色时，标准输出是 TTY。 默认是自动的。 pwn disablenx (检查elf安全机制)12345678910111213141516usage: pwn disablenx [-h] elf [elf ...]l0ser@DESKTOP-N2FHDCM:/mnt/k/pwn/gxnnctf/pwn_x64$ pwn disablenx pwn[*] &apos;/mnt/k/pwn/gxnnctf/pwn_x64/pwn&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)[*] &apos;/mnt/k/pwn/gxnnctf/pwn_x64/pwn&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 1elf 要检查的文件 1-h, --help 显示这个帮助信息 pwn shellcraft (shellcode生成器)1234usage: pwn shellcraft [-h] [-?] [-o file] [-f format] [-d] [-b] [-a] [-v AVOID] [-n] [-z] [-r] [--color] [--no-color] [--syscalls] [--address ADDRESS] [-l] [-s] [shellcode] [arg [arg ...]] 1shellcode 你想要的shellcode 1arg Argument to the chosen shellcode 1-h, --help 显示这个帮助信息，然后退出 1-?, --show 打印出shellcode文件内容 1-o &lt;file&gt;, --out &lt;file&gt; Output file (default: stdout) 1-f &#123;r,raw,s,str,string,c,h,hex,a,asm,assembly,p,i,hexii,e,elf,d,escaped,default&#125;, --format &#123;r,raw,s,str,string,c,h,hex,a,asm,assembly,p,i,hexii,e,elf,d,escaped,default&#125; 输出格式(默认值: 十六进制) ，选择{ e } lf，{ r } aw，{ s } tring，{ c }-style array，{ h } ex string，hex { i } ，{ a } ssembly code，{ p } reccssed code，escape { d } hex string -d, –debug使用gdb调试shellcode 1-b, --before 在代码之前插入调试陷阱(debug trap) 1-a, --after 在代码之后插入调试陷阱(debug trap) 1-v &lt;avoid&gt;, --avoid &lt;avoid&gt; 对 shell 代码进行编码 1-n, --newline 将 shell 代码编码以避免换行 1-z, --zero 对 shell 代码进行编码，以避免NIULL bytes 1-r, --run Run output 1--color Color output 1--no-color Disable color output 1--syscalls 列出系统调用 1--address &lt;address&gt; 加载地址 1-l, --list 列出可用的shellcode，也可选择提供一个过滤器 1-s, --shared 生成的 ELF 是一个共享库 pwn template123usage: pwn template [-h] [--host HOST] [--port PORT] [--user USER] [--pass PASSWORD] [--path PATH] [--quiet] [exe] 1exe 目标二进制文件 1-h, --help 显示这个帮助信息，然后退出 1--host &lt;host&gt; 远程主机 / SSH 服务器 1--port &lt;port&gt; 远程端口 / SSH 端口 1--user &lt;user&gt; SSH 用户名 1--pass &lt;password&gt; SSH 密码 1--path &lt;path&gt; ssh 服务器上文件的远程路径 1--quiet 较少冗长的模板注释 pwn elfdiff1usage: pwn elfdiff [-h] a b ab对比a , b两个elf文件-h, –help显示这个帮助信息，然后退出 pwn pwnstrip1usage: pwn pwnstrip [-h] [-b] [-p FUNCTION] [-o OUTPUT] file file 1-h, --help 显示这个帮助信息，然后退出 1-b, --build-id Strip build ID 1-p &lt;function&gt;, --patch &lt;function&gt; Patch function 1-o &lt;output&gt;, --output &lt;output&gt; pwn constgrep12usage: pwn constgrep [-h] [-e constant] [-i] [-m] [-c arch_or_os] [regex] [constant] 1regex 要求匹配常量的正则表达式 1constant 要找的常量 1-h, --help 显示这个帮助信息，然后退出 1-e &lt;constant&gt;, --exact &lt;constant&gt; 对常量执行精确匹配，而不是搜索正则表达式 1-i, --case-insensitive 搜索不区分大小写 1-m, --mask-mode 不要搜索特定的常量值，而是搜索不严格包含比给定值少的位的值。 1-c &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125;, --context &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125; 指定生成的shellcode的 操作系统 / 架构 / 字节序(大端小端) / 位数 (默认是: linux/i386), 从: [‘16’, ‘32’, ‘64’, ‘android’, ‘cgc’, ‘freebsd’, ‘linux’, ‘windows’, ‘powerpc64’, ‘aarch64’, ‘sparc64’, ‘powerpc’, ‘mips64’, ‘msp430’, ‘thumb’, ‘amd64’, ‘sparc’, ‘alpha’, ‘s390’, ‘i386’, ‘m68k’, ‘mips’, ‘ia64’, ‘cris’, ‘vax’, ‘avr’, ‘arm’, ‘little’, ‘big’, ‘el’, ‘le’, ‘be’, ‘eb’]中选择 pwn debug123usage: pwn debug [-h] [-x GDBSCRIPT] [--pid PID] [-c context] [--exec EXECUTABLE] [--process PROCESS_NAME] [--sysroot SYSROOT] 1-h, --help 显示这个帮助信息，然后退出 1-x &lt;gdbscript&gt; 从该文件执行 GDB 命令。 1--pid &lt;pid&gt; PID to attach to 1-c &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125;, --context &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125; 指定生成的shellcode的 操作系统 / 架构 / 字节序(大端小端) / 位数 (默认是: linux/i386), 从: [‘16’, ‘32’, ‘64’, ‘android’, ‘cgc’, ‘freebsd’, ‘linux’, ‘windows’, ‘powerpc64’, ‘aarch64’, ‘sparc64’, ‘powerpc’, ‘mips64’, ‘msp430’, ‘thumb’, ‘amd64’, ‘sparc’, ‘alpha’, ‘s390’, ‘i386’, ‘m68k’, ‘mips’, ‘ia64’, ‘cris’, ‘vax’, ‘avr’, ‘arm’, ‘little’, ‘big’, ‘el’, ‘le’, ‘be’, ‘eb’]中选择 1--exec &lt;executable&gt; 要调试的文件 1--process &lt;process_name&gt; 要attach的进程的名称(例如”bash”) 1--sysroot &lt;sysroot&gt; GDB sysroot path pwn elfpatch1usage: pwn elfpatch [-h] -h, –help显示这个帮助信息，然后退出 pwn errno1usage: pwn errno [-h] error error错误消息或值-h, –help显示这个帮助信息，然后退出 ###pwn scramble12usage: pwn scramble [-h] [-f &#123;raw,hex,string,elf&#125;] [-o file] [-c context] [-p] [-v AVOID] [-n] [-z] [-d] 1-h, --help 显示这个帮助信息，然后退出 1-f &#123;raw,hex,string,elf&#125;, --format &#123;raw,hex,string,elf&#125; 输出格式(对于 ttys，默认为十六进制，否则为原始数据) 1-o &lt;file&gt;, --output &lt;file&gt; 输出文件(默认为 stdout) 1-c &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125;, --context &#123;16,32,64,android,cgc,freebsd,linux,windows,powerpc64,aarch64,sparc64,powerpc,mips64,msp430,thumb,amd64,sparc,alpha,s390,i386,m68k,mips,ia64,cris,vax,avr,arm,little,big,el,le,be,eb&#125; 指定生成的shellcode的 操作系统 / 架构 / 字节序(大端小端) / 位数 (默认是: linux/i386), 从: [‘16’, ‘32’, ‘64’, ‘android’, ‘cgc’, ‘freebsd’, ‘linux’, ‘windows’, ‘powerpc64’, ‘aarch64’, ‘sparc64’, ‘powerpc’, ‘mips64’, ‘msp430’, ‘thumb’, ‘amd64’, ‘sparc’, ‘alpha’, ‘s390’, ‘i386’, ‘m68k’, ‘mips’, ‘ia64’, ‘cris’, ‘vax’, ‘avr’, ‘arm’, ‘little’, ‘big’, ‘el’, ‘le’, ‘be’, ‘eb’]中选择 -p, –alphanumericEncode the shellcode with an alphanumeric encoder -v , –avoid 对 shell 代码进行编码 -n, –newline将 shell 代码编码以避免换行 -z, –zero对 shell 代码进行编码，以避免NIULL bytes -d, –debug使用gdb调试shellcode","categories":[],"tags":[{"name":"pwntools","slug":"pwntools","permalink":"http://zero-mk.github.io/tags/pwntools/"}]},{"title":"ctf-pwn-tips-zh_CN","slug":"CTF-pwn-tips-zh_CN","date":"2018-12-31T08:39:34.000Z","updated":"2018-12-31T18:43:48.810Z","comments":true,"path":"2018/12/31/CTF-pwn-tips-zh_CN/","link":"","permalink":"http://zero-mk.github.io/2018/12/31/CTF-pwn-tips-zh_CN/","excerpt":"","text":"Catalog Overflow Find string in gdb Binary Service Find specific function offset in libc Find ‘/bin/sh’ or ‘sh’ in library Leak stack address Fork problem in gdb Secret of a mysterious section - .tls Predictable RNG(Random Number Generator) Make stack executable Use one-gadget-RCE instead of system Hijack hook function Use printf to trigger malloc and free Use execveat to open a shell Overflow例如:12char buf[40]signed int num scanf1scanf(\"%s\", buf) %s 没有边界检查 pwnable 1scanf(\"%39s\", buf) 39s 只从输入中获取39个字节，并将 NULL 字节放在输入的末尾。 useless 1scanf(\"%40s\", buf) 乍一看，这似乎是合理的。 它从输入中获取40字节，但它也将NULL字节放在输入的末尾。 但是,它有one-byte-overflow pwnable 12scanf(\"%d\", &amp;num)alloca(num) * 由于`alloca`从调用者的堆栈框架分配内存，因此有一条` sub esp, eax `指令来实现这一点。 * 如果我们使num为负，它将有重叠的堆栈帧。 * E.g. [Seccon CTF quals 2016 cheer_msg](https://github.com/ctfs/write-ups-2016/tree/master/seccon-ctf-quals-2016/exploit/cheer-msg-100) 使用num访问一些数据结构 大多数情况下，程序只检查较高的边界，忘记使num无符号。 使num为负可以让我们覆盖一些重要的数据 gets1gets(buf) 没有检查边界 pwnable 1fgets(buf, 40, stdin) 它只从输入中获取39个字节，并将NULL字节放在输入的末尾。 useless read1read(stdin, buf, 40) 它从输入中获取40字节，并且不将NULL字节放在输入的末尾。 这看起来很安全，但可能会有 information leak. leakable E.g. memory layout1230x7fffffffdd00: 0x4141414141414141 0x41414141414141410x7fffffffdd10: 0x4141414141414141 0x41414141414141410x7fffffffdd20: 0x4141414141414141 0x00007fffffffe1cd 如果现在用printf或者puts来输出这个buf,它将一直输出到NULL byte. 在这种情况下，我们可以:1&apos;A&apos;*40 + &apos;\\xcd\\xe1\\xff\\xff\\xff\\x7f&apos; 1fread(buf, 1, 40, stdin) 几乎和read一样 leakable strcpy假设还有另一个缓冲区:1char buf2[60] 1strcpy(buf, buf2) 没有边界检查 buf2的大小可能比buf大 所以可能会buffer overflow pwnable 12strncpy(buf, buf2, 40)memcpy(buf, buf2, 40) 这个操作会把buf2前40 bytes复制到buf,但是不会再末尾添加NULL byte 因为结尾没有NULL byte, 也许可以 information leak. leakable strcat假设有:1char buf2[60] 1strcat(buf, buf2) strcat是将两个char类型连接。 如果buf不够大，可能会导致溢出。 它将NULL byte放在末尾，这可能会导致one-byte-overflow. 在某些情况下，我们可以使用这个NULL byte来更改堆栈地址或堆地址。 pwnable 1strncat(buf, buf2, n) 和strcat相似, 但是有大小n限制 pwnable E.g. Seccon CTF quals 2016 jmper Find string in gdb在 SSP中, 我们需要找出argv[0]和输入缓冲区之间的偏移量。 gdb Use p/x ((char **)environ) in gdb, and the address of argv[0] will be the output - 0x10 在gdb中使用p/x ((char **)environ)， argv[0]的地址将是output - 0x10 E.g. 123456(gdb) p/x (char **)environ$9 = 0x7fffffffde38(gdb) x/gx 0x7fffffffde38-0x100x7fffffffde28: 0x00007fffffffe1cd(gdb) x/s 0x00007fffffffe1cd0x7fffffffe1cd: &quot;/home/naetw/CTF/seccon2016/check/checker&quot; gdb peda 使用 searchmem搜索内存123Usage: searchmem pattern start end searchmem pattern mapname 1234567891011gdb-peda$ searchmem &quot;/home/naetw/CTF/seccon2016/check/checker&quot;Searching for &apos;/home/naetw/CTF/seccon2016/check/checker&apos; in: None rangesFound 3 results, display max 3 items:[stack] : 0x7fffffffe1cd (&quot;/home/naetw/CTF/seccon2016/check/checker&quot;)[stack] : 0x7fffffffed7c (&quot;/home/naetw/CTF/seccon2016/check/checker&quot;)[stack] : 0x7fffffffefcf (&quot;/home/naetw/CTF/seccon2016/check/checker&quot;)gdb-peda$ searchmem 0x7fffffffe1cdSearching for &apos;0x7fffffffe1cd&apos; in: None rangesFound 2 results, display max 2 items: libc : 0x7ffff7dd33b8 --&gt; 0x7fffffffe1cd (&quot;/home/naetw/CTF/seccon2016/check/checker&quot;)[stack] : 0x7fffffffde28 --&gt; 0x7fffffffe1cd (&quot;/home/naetw/CTF/seccon2016/check/checker&quot;) Binary Service不需要使用共享库的binary: 1ncat -vc ./binary -kl $ip $port 需要使用共享库的binary: 12ncat -vc &apos;LD_PRELOAD=/path/to/libc.so ./binary&apos; -kl $ip $portncat -vc &apos;LD_LIBRARY_PATH=/path/of/libc.so ./binary&apos; -kl $ip $port 在此之后，您可以通过nc连接到二进制服务1nc $ip $port Find specific function offset in libc如果我们成功地泄漏了某个函数的libc地址，我们可以通过用函数在libc地址减去该函数的偏移量来得到libc的基地址。 Manually1readelf -s libc名 | grep 函数名@ E.g. 123$ readelf -s libc-2.19.so | grep system@ 620: 00040310 56 FUNC GLOBAL DEFAULT 12 __libc_system@@GLIBC_PRIVATE 1443: 00040310 56 FUNC WEAK DEFAULT 12 system@@GLIBC_2.0 Automatically 使用 pwntools E.g. 1234from pwn import *libc = ELF(&apos;libc.so&apos;)system_off = libc.symbols[&apos;system&apos;] Find ‘/bin/sh’ or ‘sh’ in library先得到libc的基地址 Manually12objdump -s libc.so | less (search &apos;sh&apos;)strings -tx libc.so | grep /bin/sh Automatically 使用 pwntools E.g. 123456from pwn import *libc = ELF(&apos;libc.so&apos;)...sh = base + next(libc.search(&apos;sh\\x00&apos;))binsh = base + next(libc.search(&apos;/bin/sh\\x00&apos;)) 译者注 : next(libc.search(some_characters)) 在libc找到包含 some_characters（字符串，汇编代码或者某个数值）的地址 Leak stack addressconstraints: libc的基地地址已经泄露了吗 可以泄露任意地址的内容吗 有一个 symbol environ 在libc中,它的值与main函数的第三个参数char **envp相同。 char **envp ‘的值在堆栈上，因此我们可以使用这个 symbol泄漏堆栈地址。 1234567891011121314(gdb) list 11 #include &lt;stdlib.h&gt;2 #include &lt;stdio.h&gt;34 extern char **environ;56 int main(int argc, char **argv, char **envp)7 &#123;8 return 0;9 &#125;(gdb) x/gx 0x7ffff7a0e000 + 0x3c5f380x7ffff7dd3f38 &lt;environ&gt;: 0x00007fffffffe230(gdb) p/x (char **)envp$12 = 0x7fffffffe230 当前的libc基地址是 0x7ffff7a0e000 environ在libc的偏移量为0x3c5f38 这本 手册 详细解释了 environ Fork problem in gdb当您使用gdb调试一个带有fork()函数的二进制文件时，您可以使用以下命令来确定要执行哪个进程(原始gdb的默认设置是父进程，而gdb-peda的默认设置是子进程): 12set follow-fork-mode parentset follow-fork-mode child Alternatively, using set detach-on-fork off, we can then control both sides of each fork. Using inferior X where X is any of the numbers that show up for info inferiors will switch to that side of the fork. This is useful if both sides of the fork are necessary to attack a challenge, and the simple follow ones above aren’t sufficient.或者，使用set detach-on-fork off，我们可以控制每个fork的两边。使用inferior X，其中X是出现在info inferiors中的任何一个数字，都会切换到fork的那一边。如果分支的两端都是攻击某个挑战所必需的，并且上面简单的follow操作还不够，那么这种方法非常有用。1234gdb-peda$ info inferiors Num Description Executable* 1 xxxx xxxxx 2 xxxx xxxxx Secret of a mysterious section - .tlsconstraints: Need malloc function and you can malloc with arbitrary size Arbitrary address leaking We make malloc use mmap to allocate memory(size 0x21000 is enough). In general, these pages will be placed at the address just before .tls section. There is some useful information on .tls, such as the address of main_arena, canary (value of stack guard), and a strange stack address which points to somewhere on the stack but with a fixed offset. Before calling mmap: 123456787fecbfe4d000-7fecbfe51000 r--p 001bd000 fd:00 131210 /lib/x86_64-linux-gnu/libc-2.24.so7fecbfe51000-7fecbfe53000 rw-p 001c1000 fd:00 131210 /lib/x86_64-linux-gnu/libc-2.24.so7fecbfe53000-7fecbfe57000 rw-p 00000000 00:00 07fecbfe57000-7fecbfe7c000 r-xp 00000000 fd:00 131206 /lib/x86_64-linux-gnu/ld-2.24.so7fecc0068000-7fecc006a000 rw-p 00000000 00:00 0 &lt;- .tls section7fecc0078000-7fecc007b000 rw-p 00000000 00:00 07fecc007b000-7fecc007c000 r--p 00024000 fd:00 131206 /lib/x86_64-linux-gnu/ld-2.24.so7fecc007c000-7fecc007d000 rw-p 00025000 fd:00 131206 /lib/x86_64-linux-gnu/ld-2.24.so After call mmap: 123456787fecbfe4d000-7fecbfe51000 r--p 001bd000 fd:00 131210 /lib/x86_64-linux-gnu/libc-2.24.so7fecbfe51000-7fecbfe53000 rw-p 001c1000 fd:00 131210 /lib/x86_64-linux-gnu/libc-2.24.so7fecbfe53000-7fecbfe57000 rw-p 00000000 00:00 07fecbfe57000-7fecbfe7c000 r-xp 00000000 fd:00 131206 /lib/x86_64-linux-gnu/ld-2.24.so7fecc0045000-7fecc006a000 rw-p 00000000 00:00 0 &lt;- memory of mmap + .tls section7fecc0078000-7fecc007b000 rw-p 00000000 00:00 07fecc007b000-7fecc007c000 r--p 00024000 fd:00 131206 /lib/x86_64-linux-gnu/ld-2.24.so7fecc007c000-7fecc007d000 rw-p 00025000 fd:00 131206 /lib/x86_64-linux-gnu/ld-2.24.so Predictable RNG(Random Number Generator)When the binary uses the RNG to make the address of important information or sth, we can guess the same value if it’s predictable. Assuming that it’s predictable, we can use ctypes which is a build-in module in Python. ctypes allows calling a function in DLL(Dynamic-Link Library) or Shared Library. Therefore, if binary has an init_proc like this: 123456789srand(time(NULL));while(addr &lt;= 0x10000)&#123; addr = rand() &amp; 0xfffff000;&#125;secret = mmap(addr,0x1000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS ,-1,0);if(secret == -1)&#123; puts(`mmap error`); exit(0);&#125; Then we can use ctypes to get the same value of addr. 1234import ctypesLIBC = ctypes.cdll.LoadLibrary(&apos;/path/to/dll&apos;)LIBC.srand(LIBC.time(0))addr = LIBC.rand() &amp; 0xfffff000 Make stack executable link1 link2 Haven’t read yet orz Use one-gadget-RCE instead of systemconstraints: 有libc的基本地址 任意地址写 几乎每个pwnable挑战都需要在攻击结束时调用system(&quot;/bin/sh&quot;)，但是如果我们想调用它，我们必须操纵参数，当然，还需要劫持一些函数来调用’system。如果我们不能操纵参数怎么办? 使用 one-gadget-RCE! 用 one-gadget-RCE, 我们就劫持 .got.plt 或者我们可以用它来控制eip 使程序跳转到 one-gadget, 但是在使用它之前需要满足一些constraintlibc中有很多one-gadgets. 每个都有不同的constraints，但它们是相似的。每个constraints都与寄存器的状态有关。 E.g. ebx 在libc里的地址是 rw-p 的 [esp+0x34] == NULL 我们如何得到这些constraints? 这里有一个有效的工具 one_gadget !!!! 如果我们能满足这些constraints, 我们就可以轻易getshell Hijack hook functionconstraints: 有libc基地址 任意地址写 程序有用到 malloc, free or realloc By manual: 原文:The GNU C Library lets you modify the behavior of malloc, realloc, and free by specifying appropriate hook functions. You can use these hooks to help you debug programs that use dynamic memory allocation, for example.译文:GNU C库允许您通过指定适当的hook函数来修改malloc、realloc和free的行为。例如，您可以使用这些hook来帮助调试使用动态内存分配的程序。 malloc.h中声明了一些hook变量。它们的默认值是0x0 123__malloc_hook__free_hook... 因为它们用于帮助用户调试程序，所以它们在执行的时候是可写的。 120xf77228e0 &lt;__free_hook&gt;: 0x000000000xf7722000 0xf7727000 rw-p mapped 这是malloc.c的源码.下面我使用 __libc_free来演示 123456void (*hook) (void *, const void *) = atomic_forced_read (__free_hook);if (__builtin_expect (hook != NULL, 0))&#123; (*hook)(mem, RETURN_ADDRESS (0)); return;&#125; 它检查__free_hook的值。如果不是NULL，它将首先调用hook函数。在这里，我们希望使用one-gadget-RCE。由于hook函数是在libc中调用的，所以通常满足one-gadget的constraints。 Use printf to trigger malloc and free查看printf函数的源码,有几个地方可能会触发malloc. 拿 vfprintf.c line 1470 来做例子: 1234567891011121314151617181920#define EXTSIZ 32enum &#123; WORK_BUFFER_SIZE = 1000 &#125;;if (width &gt;= WORK_BUFFER_SIZE - EXTSIZ)&#123; /* 我们必须使用一个特殊的缓冲区。 */ size_t needed = ((size_t) width + EXTSIZ) * sizeof (CHAR_T); if (__libc_use_alloca (needed)) workend = (CHAR_T *) alloca (needed) + width + EXTSIZ; else &#123; workstart = (CHAR_T *) malloc (needed); if (workstart == NULL) &#123; done = -1; goto all_done; &#125; workend = workstart + width + EXTSIZ; &#125;&#125; We can find that malloc will be triggered if the width field is large enough.(Of course, free will also be triggered at the end of printf if malloc has been triggered.) However, WORK_BUFFER_SIZE is not large enough, since we need to go to else block. Let’s take a look at __libc_use_alloca and see what exactly the minimum size of width we should give. 我们可以发现，如果width field足够大，将触发malloc。(当然，如果malloc被触发，那么free也会在printf的末尾被触发。)但是，WORK_BUFFER_SIZE不够大，所以我们需要转到else块从而触发mallco。让我们看看__libc_use_alloca，看看应该给出的最小宽度是多少。 12345678910111213141516171819/* 线程的最小大小。我们可以自由选择一个合理的值 */#define PTHREAD_STACK_MIN 16384#define __MAX_ALLOCA_CUTOFF 65536int __libc_use_alloca (size_t size)&#123; return (__builtin_expect (size &lt;= PTHREAD_STACK_MIN / 4, 1) || __builtin_expect (__libc_alloca_cutoff (size), 1));&#125;int __libc_alloca_cutoff (size_t size)&#123; return size &lt;= (MIN (__MAX_ALLOCA_CUTOFF, THREAD_GETMEM (THREAD_SELF, stackblock_size) / 4 /* 在初始化线程库之前，主线程在stackblock_size元素中为零。因为它是主线程，所以我们可以假设最大可用堆栈空间。 */ ?: __MAX_ALLOCA_CUTOFF * 4));&#125; 我们必须确保: 12size &gt; PTHREAD_STACK_MIN / 4size &gt; MIN(__MAX_ALLOCA_CUTOFF, THREAD_GETMEM(THREAD_SELF, stackblock_size) / 4 ?: __MAX_ALLOCA_CUTOFF * 4) 我并没有完全理解函数THREAD_GETMEM的作用，但它似乎主要返回0。 第二个条件通常是 size &gt; 65536 More details: __builtin_expect THREAD_GETMEM conclusion 触发malloc和free的最小宽度通常是65537。 If there is a Format String Vulnerability and the program ends right after calling printf(buf), we can hijack __malloc_hook or __free_hook with one-gadget and use the trick mentioned above to trigger malloc &amp; free then we can still get the shell even there is no more function call or sth after printf(buf).(如果有一个格式字符串漏洞,程序结束后调用printf(buf),我们可以用one-gadget劫持__malloc_hook或__free_hook,使用上面提到的技巧来触发malloc&amp;free然后我们仍然可以得到shell后没有更多的函数调用printf(buf)。) Use execveat to open a shell提到用系统调用getshell时，我们会想到execve。但是，由于缺少gadgets或其他的constraints，通常并不是很容易就能办到。有一个系统调用execveat，原型如下: 123int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags); According to its man page, it operates in the same way as execve. As for the additional arguments, it mentions that:根据其手册得知，它的运作方式与execve相同。至于其他不同点，它提到: If pathname is absolute, then dirfd is ignored.如果路径名是绝对的，那么dirfd将被忽略。 Hence, if we make pathname point to /bin/sh, and set argv, envp and flags to 0, we can still get a shell whatever the value of dirfd.因此，如果我们让pathname为/bin/sh，并将argv、‘envp’和‘flags’设置为0，那么无论dirfd的值是多少，我们仍然可以getshell。 原文:https://github.com/Naetw/CTF-pwn-tips译者:l0ser","categories":[],"tags":[{"name":"ctf-pwn","slug":"ctf-pwn","permalink":"http://zero-mk.github.io/tags/ctf-pwn/"}]},{"title":"Linux_System_Call_Table","slug":"syscall","date":"2018-12-20T08:39:34.000Z","updated":"2018-12-31T18:11:12.915Z","comments":true,"path":"2018/12/20/syscall/","link":"","permalink":"http://zero-mk.github.io/2018/12/20/syscall/","excerpt":"","text":"x64_system_call:原表位于 : http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/ %rax System call %rdi %rsi %rdx %r10 %r8 %r9 0 sys_read unsigned int fd char *buf size_t count 1 sys_write unsigned int fd const char *buf size_t count 2 sys_open const char *filename int flags int mode 3 sys_close unsigned int fd 4 sys_stat const char *filename struct stat *statbuf 5 sys_fstat unsigned int fd struct stat *statbuf 6 sys_lstat fconst char *filename struct stat *statbuf 7 sys_poll struct poll_fd *ufds unsigned int nfds long timeout_msecs 8 sys_lseek unsigned int fd off_t offset unsigned int origin 9 sys_mmap unsigned long addr unsigned long len unsigned long prot unsigned long flags unsigned long fd unsigned long off 10 sys_mprotect unsigned long start size_t len unsigned long prot 11 sys_munmap unsigned long addr size_t len 12 sys_brk unsigned long brk 13 sys_rt_sigaction int sig const struct sigaction *act struct sigaction *oact size_t sigsetsize 14 sys_rt_sigprocmask int how sigset_t *nset sigset_t *oset size_t sigsetsize 15 sys_rt_sigreturn unsigned long __unused 16 sys_ioctl unsigned int fd unsigned int cmd unsigned long arg 17 sys_pread64 unsigned long fd char *buf size_t count loff_t pos 18 sys_pwrite64 unsigned int fd const char *buf size_t count loff_t pos 19 sys_readv unsigned long fd const struct iovec *vec unsigned long vlen 20 sys_writev unsigned long fd const struct iovec *vec unsigned long vlen 21 sys_access const char *filename int mode 22 sys_pipe int *filedes 23 sys_select int n fd_set *inp fd_set *outp fd_set*exp struct timeval *tvp 24 sys_sched_yield 25 sys_mremap unsigned long addr unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr 26 sys_msync unsigned long start size_t len int flags 27 sys_mincore unsigned long start size_t len unsigned char *vec 28 sys_madvise unsigned long start size_t len_in int behavior 29 sys_shmget key_t key size_t size int shmflg 30 sys_shmat int shmid char *shmaddr int shmflg 31 sys_shmctl int shmid int cmd struct shmid_ds *buf 32 sys_dup unsigned int fildes 33 sys_dup2 unsigned int oldfd unsigned int newfd 34 sys_pause 35 sys_nanosleep struct timespec *rqtp struct timespec *rmtp 36 sys_getitimer int which struct itimerval *value 37 sys_alarm unsigned int seconds 38 sys_setitimer int which struct itimerval *value struct itimerval *ovalue 39 sys_getpid 40 sys_sendfile int out_fd int in_fd off_t *offset size_t count 41 sys_socket int family int type int protocol 42 sys_connect int fd struct sockaddr *uservaddr int addrlen 43 sys_accept int fd struct sockaddr *upeer_sockaddr int *upeer_addrlen 44 sys_sendto int fd void *buff size_t len unsigned flags struct sockaddr *addr int addr_len 45 sys_recvfrom int fd void *ubuf size_t size unsigned flags struct sockaddr *addr int *addr_len 46 sys_sendmsg int fd struct msghdr *msg unsigned flags 47 sys_recvmsg int fd struct msghdr *msg unsigned int flags 48 sys_shutdown int fd int how 49 sys_bind int fd struct sokaddr *umyaddr int addrlen 50 sys_listen int fd int backlog 51 sys_getsockname int fd struct sockaddr *usockaddr int *usockaddr_len 52 sys_getpeername int fd struct sockaddr *usockaddr int *usockaddr_len 53 sys_socketpair int family int type int protocol int *usockvec 54 sys_setsockopt int fd int level int optname char *optval int optlen 55 sys_getsockopt int fd int level int optname char *optval int *optlen 56 sys_clone unsigned long clone_flags unsigned long newsp void *parent_tid void *child_tid 57 sys_fork 58 sys_vfork 59 sys_execve const char *filename const char *const argv[] const char *const envp[] 60 sys_exit int error_code 61 sys_wait4 pid_t upid int *stat_addr int options struct rusage *ru 62 sys_kill pid_t pid int sig 63 sys_uname struct old_utsname *name 64 sys_semget key_t key int nsems int semflg 65 sys_semop int semid struct sembuf *tsops unsigned nsops 66 sys_semctl int semid int semnum int cmd union semun arg 67 sys_shmdt char *shmaddr 68 sys_msgget key_t key int msgflg 69 sys_msgsnd int msqid struct msgbuf *msgp size_t msgsz int msgflg 70 sys_msgrcv int msqid struct msgbuf *msgp size_t msgsz long msgtyp int msgflg 71 sys_msgctl int msqid int cmd struct msqid_ds *buf 72 sys_fcntl unsigned int fd unsigned int cmd unsigned long arg 73 sys_flock unsigned int fd unsigned int cmd 74 sys_fsync unsigned int fd 75 sys_fdatasync unsigned int fd 76 sys_truncate const char *path long length 77 sys_ftruncate unsigned int fd unsigned long length 78 sys_getdents unsigned int fd struct linux_dirent *dirent unsigned int count 79 sys_getcwd char *buf unsigned long size 80 sys_chdir const char *filename 81 sys_fchdir unsigned int fd 82 sys_rename const char *oldname const char *newname 83 sys_mkdir const char *pathname int mode 84 sys_rmdir const char *pathname 85 sys_creat const char *pathname int mode 86 sys_link const char *oldname const char *newname 87 sys_unlink const char *pathname 88 sys_symlink const char *oldname const char *newname 89 sys_readlink const char *path char *buf int bufsiz 90 sys_chmod const char *filename mode_t mode 91 sys_fchmod unsigned int fd mode_t mode 92 sys_chown const char *filename uid_t user gid_t group 93 sys_fchown unsigned int fd uid_t user gid_t group 94 sys_lchown const char *filename uid_t user gid_t group 95 sys_umask int mask 96 sys_gettimeofday struct timeval *tv struct timezone *tz 97 sys_getrlimit unsigned int resource struct rlimit *rlim 98 sys_getrusage int who struct rusage *ru 99 sys_sysinfo struct sysinfo *info 100 sys_times struct sysinfo *info 101 sys_ptrace long request long pid unsigned long addr unsigned long data 102 sys_getuid 103 sys_syslog int type char *buf int len 104 sys_getgid 105 sys_setuid uid_t uid 106 sys_setgid gid_t gid 107 sys_geteuid 108 sys_getegid 109 sys_setpgid pid_t pid pid_t pgid 110 sys_getppid 111 sys_getpgrp 112 sys_setsid 113 sys_setreuid uid_t ruid uid_t euid 114 sys_setregid gid_t rgid gid_t egid 115 sys_getgroups int gidsetsize gid_t *grouplist 116 sys_setgroups int gidsetsize gid_t *grouplist 117 sys_setresuid uid_t *ruid uid_t *euid uid_t *suid 118 sys_getresuid uid_t *ruid uid_t *euid uid_t *suid 119 sys_setresgid gid_t rgid gid_t egid gid_t sgid 120 sys_getresgid gid_t *rgid gid_t *egid gid_t *sgid 121 sys_getpgid pid_t pid 122 sys_setfsuid uid_t uid 123 sys_setfsgid gid_t gid 124 sys_getsid pid_t pid 125 sys_capget cap_user_header_t header cap_user_data_t dataptr 126 sys_capset cap_user_header_t header const cap_user_data_t data 127 sys_rt_sigpending sigset_t *set size_t sigsetsize 128 sys_rt_sigtimedwait const sigset_t *uthese siginfo_t *uinfo const struct timespec *uts size_t sigsetsize 129 sys_rt_sigqueueinfo pid_t pid int sig siginfo_t *uinfo 130 sys_rt_sigsuspend sigset_t *unewset size_t sigsetsize 131 sys_sigaltstack const stack_t *uss stack_t *uoss 132 sys_utime char *filename struct utimbuf *times 133 sys_mknod const char *filename umode_t mode unsigned dev 134 sys_uselib NOT IMPLEMENTED 135 sys_personality unsigned int personality 136 sys_ustat unsigned dev struct ustat *ubuf 137 sys_statfs const char *pathname struct statfs *buf 138 sys_fstatfs unsigned int fd struct statfs *buf 139 sys_sysfs int option unsigned long arg1 unsigned long arg2 140 sys_getpriority int which int who 141 sys_setpriority int which int who int niceval 142 sys_sched_setparam pid_t pid struct sched_param *param 143 sys_sched_getparam pid_t pid struct sched_param *param 144 sys_sched_setscheduler pid_t pid int policy struct sched_param *param 145 sys_sched_getscheduler pid_t pid 146 sys_sched_get_priority_max int policy 147 sys_sched_get_priority_min int policy 148 sys_sched_rr_get_interval pid_t pid struct timespec *interval 149 sys_mlock unsigned long start size_t len 150 sys_munlock unsigned long start size_t len 151 sys_mlockall int flags 152 sys_munlockall 153 sys_vhangup 154 sys_modify_ldt int func void *ptr unsigned long bytecount 155 sys_pivot_root const char *new_root const char *put_old 156 sys__sysctl struct __sysctl_args *args 157 sys_prctl int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 158 sys_arch_prctl struct task_struct *task int code unsigned long *addr 159 sys_adjtimex struct timex *txc_p 160 sys_setrlimit unsigned int resource struct rlimit *rlim 161 sys_chroot const char *filename 162 sys_sync 163 sys_acct const char *name 164 sys_settimeofday struct timeval *tv struct timezone *tz 165 sys_mount char *dev_name char *dir_name char *type unsigned long flags void *data 166 sys_umount2 const char *target int flags 167 sys_swapon const char *specialfile int swap_flags 168 sys_swapoff const char *specialfile 169 sys_reboot int magic1 int magic2 unsigned int cmd void *arg 170 sys_sethostname char *name int len 171 sys_setdomainname char *name int len 172 sys_iopl unsigned int level struct pt_regs *regs 173 sys_ioperm unsigned long from unsigned long num int turn_on 174 sys_create_module REMOVED IN Linux 2.6 175 sys_init_module void *umod unsigned long len const char *uargs 176 sys_delete_module const chat *name_user unsigned int flags 177 sys_get_kernel_syms REMOVED IN Linux 2.6 178 sys_query_module REMOVED IN Linux 2.6 179 sys_quotactl unsigned int cmd const char *special qid_t id void *addr 180 sys_nfsservctl NOT IMPLEMENTED 181 sys_getpmsg NOT IMPLEMENTED 182 sys_putpmsg NOT IMPLEMENTED 183 sys_afs_syscall NOT IMPLEMENTED 184 sys_tuxcall NOT IMPLEMENTED 185 sys_security NOT IMPLEMENTED 186 sys_gettid 187 sys_readahead int fd loff_t offset size_t count 188 sys_setxattr const char *pathname const char *name const void *value size_t size int flags 189 sys_lsetxattr const char *pathname const char *name const void *value size_t size int flags 190 sys_fsetxattr int fd const char *name const void *value size_t size int flags 191 sys_getxattr const char *pathname const char *name void *value size_t size 192 sys_lgetxattr const char *pathname const char *name void *value size_t size 193 sys_fgetxattr int fd const har *name void *value size_t size 194 sys_listxattr const char *pathname char *list size_t size 195 sys_llistxattr const char *pathname char *list size_t size 196 sys_flistxattr int fd char *list size_t size 197 sys_removexattr const char *pathname const char *name 198 sys_lremovexattr const char *pathname const char *name 199 sys_fremovexattr int fd const char *name 200 sys_tkill pid_t pid ing sig 201 sys_time time_t *tloc 202 sys_futex u32 *uaddr int op u32 val struct timespec *utime u32 *uaddr2 u32 val3 203 sys_sched_setaffinity pid_t pid unsigned int len unsigned long *user_mask_ptr 204 sys_sched_getaffinity pid_t pid unsigned int len unsigned long *user_mask_ptr 205 sys_set_thread_area NOT IMPLEMENTED. Use arch_prctl 206 sys_io_setup unsigned nr_events aio_context_t *ctxp 207 sys_io_destroy aio_context_t ctx 208 sys_io_getevents aio_context_t ctx_id long min_nr long nr struct io_event *events 209 sys_io_submit aio_context_t ctx_id long nr struct iocb **iocbpp 210 sys_io_cancel aio_context_t ctx_id struct iocb *iocb struct io_event *result 211 sys_get_thread_area NOT IMPLEMENTED. Use arch_prctl 212 sys_lookup_dcookie u64 cookie64 long buf long len 213 sys_epoll_create int size 214 sys_epoll_ctl_old NOT IMPLEMENTED 215 sys_epoll_wait_old NOT IMPLEMENTED 216 sys_remap_file_pages unsigned long start unsigned long size unsigned long prot unsigned long pgoff unsigned long flags 217 sys_getdents64 unsigned int fd struct linux_dirent64 *dirent unsigned int count 218 sys_set_tid_address int *tidptr 219 sys_restart_syscall 220 sys_semtimedop int semid struct sembuf *tsops unsigned nsops const struct timespec *timeout 221 sys_fadvise64 int fd loff_t offset size_t len int advice 222 sys_timer_create const clockid_t which_clock struct sigevent *timer_event_spec timer_t *created_timer_id 223 sys_timer_settime timer_t timer_id int flags const struct itimerspec *new_setting struct itimerspec *old_setting 224 sys_timer_gettime timer_t timer_id struct itimerspec *setting 225 sys_timer_getoverrun timer_t timer_id 226 sys_timer_delete timer_t timer_id 227 sys_clock_settime const clockid_t which_clock const struct timespec *tp 228 sys_clock_gettime const clockid_t which_clock struct timespec *tp 229 sys_clock_getres const clockid_t which_clock struct timespec *tp 230 sys_clock_nanosleep const clockid_t which_clock int flags const struct timespec *rqtp struct timespec *rmtp 231 sys_exit_group int error_code 232 sys_epoll_wait int epfd struct epoll_event *events int maxevents int timeout 233 sys_epoll_ctl int epfd int op int fd struct epoll_event *event 234 sys_tgkill pid_t tgid pid_t pid int sig 235 sys_utimes char *filename struct timeval *utimes 236 sys_vserver NOT IMPLEMENTED 237 sys_mbind unsigned long start unsigned long len unsigned long mode unsigned long *nmask unsigned long maxnode unsigned flags 238 sys_set_mempolicy int mode unsigned long *nmask unsigned long maxnode 239 sys_get_mempolicy int *policy unsigned long *nmask unsigned long maxnode unsigned long addr unsigned long flags 240 sys_mq_open const char *u_name int oflag mode_t mode struct mq_attr *u_attr 241 sys_mq_unlink const char *u_name 242 sys_mq_timedsend mqd_t mqdes const char *u_msg_ptr size_t msg_len unsigned int msg_prio const stuct timespec *u_abs_timeout 243 sys_mq_timedreceive mqd_t mqdes char *u_msg_ptr size_t msg_len unsigned int *u_msg_prio const struct timespec *u_abs_timeout 244 sys_mq_notify mqd_t mqdes const struct sigevent *u_notification 245 sys_mq_getsetattr mqd_t mqdes const struct mq_attr *u_mqstat struct mq_attr *u_omqstat 246 sys_kexec_load unsigned long entry unsigned long nr_segments struct kexec_segment *segments unsigned long flags 247 sys_waitid int which pid_t upid struct siginfo *infop int options struct rusage *ru 248 sys_add_key const char *_type const char *_description const void *_payload size_t plen 249 sys_request_key const char *_type const char *_description const char *_callout_info key_serial_t destringid 250 sys_keyctl int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 251 sys_ioprio_set int which int who int ioprio 252 sys_ioprio_get int which int who 253 sys_inotify_init 254 sys_inotify_add_watch int fd const char *pathname u32 mask 255 sys_inotify_rm_watch int fd __s32 wd 256 sys_migrate_pages pid_t pid unsigned long maxnode const unsigned long *old_nodes const unsigned long *new_nodes 257 sys_openat int dfd const char *filename int flags int mode 258 sys_mkdirat int dfd const char *pathname int mode 259 sys_mknodat int dfd const char *filename int mode unsigned dev 260 sys_fchownat int dfd const char *filename uid_t user gid_t group int flag 261 sys_futimesat int dfd const char *filename struct timeval *utimes 262 sys_newfstatat int dfd const char *filename struct stat *statbuf int flag 263 sys_unlinkat int dfd const char *pathname int flag 264 sys_renameat int oldfd const char *oldname int newfd const char *newname 265 sys_linkat int oldfd const char *oldname int newfd const char *newname int flags 266 sys_symlinkat const char *oldname int newfd const char *newname 267 sys_readlinkat int dfd const char *pathname char *buf int bufsiz 268 sys_fchmodat int dfd const char *filename mode_t mode 269 sys_faccessat int dfd const char *filename int mode 270 sys_pselect6 int n fd_set *inp fd_set *outp fd_set *exp struct timespec *tsp void *sig 271 sys_ppoll struct pollfd *ufds unsigned int nfds struct timespec *tsp const sigset_t *sigmask size_t sigsetsize 272 sys_unshare unsigned long unshare_flags 273 sys_set_robust_list struct robust_list_head *head size_t len 274 sys_get_robust_list int pid struct robust_list_head **head_ptr size_t *len_ptr 275 sys_splice int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 276 sys_tee int fdin int fdout size_t len unsigned int flags 277 sys_sync_file_range long fd loff_t offset loff_t bytes long flags 278 sys_vmsplice int fd const struct iovec *iov unsigned long nr_segs unsigned int flags 279 sys_move_pages pid_t pid unsigned long nr_pages const void **pages const int *nodes int *status int flags 280 sys_utimensat int dfd const char *filename struct timespec *utimes int flags 281 sys_epoll_pwait int epfd struct epoll_event *events int maxevents int timeout const sigset_t *sigmask size_t sigsetsize 282 sys_signalfd int ufd sigset_t *user_mask size_t sizemask 283 sys_timerfd_create int clockid int flags 284 sys_eventfd unsigned int count 285 sys_fallocate long fd long mode loff_t offset loff_t len 286 sys_timerfd_settime int ufd int flags const struct itimerspec *utmr struct itimerspec *otmr 287 sys_timerfd_gettime int ufd struct itimerspec *otmr 288 sys_accept4 int fd struct sockaddr *upeer_sockaddr int *upeer_addrlen int flags 289 sys_signalfd4 int ufd sigset_t *user_mask size_t sizemask int flags 290 sys_eventfd2 unsigned int count int flags 291 sys_epoll_create1 int flags 292 sys_dup3 unsigned int oldfd unsigned int newfd int flags 293 sys_pipe2 int *filedes int flags 294 sys_inotify_init1 int flags 295 sys_preadv unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h 296 sys_pwritev unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h 297 sys_rt_tgsigqueueinfo pid_t tgid pid_t pid int sig siginfo_t *uinfo 298 sys_perf_event_open struct perf_event_attr *attr_uptr pid_t pid int cpu int group_fd unsigned long flags 299 sys_recvmmsg int fd struct msghdr *mmsg unsigned int vlen unsigned int flags struct timespec *timeout 300 sys_fanotify_init unsigned int flags unsigned int event_f_flags 301 sys_fanotify_mark long fanotify_fd long flags __u64 mask long dfd long pathname 302 sys_prlimit64 pid_t pid unsigned int resource const struct rlimit64 *new_rlim struct rlimit64 *old_rlim 303 sys_name_to_handle_at int dfd const char *name struct file_handle *handle int *mnt_id int flag 304 sys_open_by_handle_at int dfd const char *name struct file_handle *handle int *mnt_id int flags 305 sys_clock_adjtime clockid_t which_clock struct timex *tx 306 sys_syncfs int fd 307 sys_sendmmsg int fd struct mmsghdr *mmsg unsigned int vlen unsigned int flags 308 sys_setns int fd int nstype 309 sys_getcpu unsigned *cpup unsigned *nodep struct getcpu_cache *unused 310 sys_process_vm_readv pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 311 sys_process_vm_writev pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovcc *rvec unsigned long riovcnt unsigned long flags 312 sys_kcmp pid_t pid1 pid_t pid2 int type unsigned long idx1 unsigned long idx2 313 sys_finit_module int fd const char __user *uargs int flags 314 sys_sched_setattr pid_t pid struct sched_attr __user *attr unsigned int flags 315 sys_sched_getattr pid_t pid struct sched_attr __user *attr unsigned int size unsigned int flags 316 sys_renameat2 int olddfd const char __user *oldname int newdfd const char __user *newname unsigned int flags 317 sys_seccomp unsigned int op unsigned int flags const char __user *uargs 318 sys_getrandom char __user *buf size_t count unsigned int flags 319 sys_memfd_create const char __user *uname_ptr unsigned int flags 320 sys_kexec_file_load int kernel_fd int initrd_fd unsigned long cmdline_len const char __user *cmdline_ptr unsigned long flags 321 sys_bpf int cmd union bpf_attr *attr unsigned int size 322 stub_execveat int dfd const char __user *filename const char user *const user *argv const char user *const user *envp int flags 323 userfaultfd int flags 324 membarrier int cmd int flags 325 mlock2 unsigned long start size_t len int flags 326 copy_file_range int fd_in loff_t __user *off_in int fd_out loff_t __user * off_out size_t len unsigned int flags 327 preadv2 unsigned long fd const struct iovec __user *vec unsigned long vlen unsigned long pos_l unsigned long pos_h int flags 328 pwritev2 unsigned long fd const struct iovec __user *vec unsigned long vlen unsigned long pos_l unsigned long pos_h int flags x86_system_call:原表地址 : https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html %eax Name Source %ebx %ecx %edx %esx %edi 1 sys_exit kernel/exit.c int - - - - 2 sys_fork arch/i386/kernel/process.c struct pt_regs - - - - 3 sys_read fs/read_write.c unsigned int char * size_t - - 4 sys_write fs/read_write.c unsigned int const char * size_t - - 5 sys_open fs/open.c const char * int int - - 6 sys_close fs/open.c unsigned int - - - - 7 sys_waitpid kernel/exit.c pid_t unsigned int * int - - 8 sys_creat fs/open.c const char * int - - - 9 sys_link fs/namei.c const char * const char * - - - 10 sys_unlink fs/namei.c const char * - - - - 11 sys_execve arch/i386/kernel/process.c struct pt_regs - - - - 12 sys_chdir fs/open.c const char * - - - - 13 sys_time kernel/time.c int * - - - - 14 sys_mknod fs/namei.c const char * int dev_t - - 15 sys_chmod fs/open.c const char * mode_t - - - 16 sys_lchown fs/open.c const char * uid_t gid_t - - 18 sys_stat fs/stat.c char * struct __old_kernel_stat * - - - 19 sys_lseek fs/read_write.c unsigned int off_t unsigned int - - 20 sys_getpid kernel/sched.c - - - - - 21 sys_mount fs/super.c char * char * char * - - 22 sys_oldumount fs/super.c char * - - - - 23 sys_setuid kernel/sys.c uid_t - - - - 24 sys_getuid kernel/sched.c - - - - - 25 sys_stime kernel/time.c int * - - - - 26 sys_ptrace arch/i386/kernel/ptrace.c long long long long - 27 sys_alarm kernel/sched.c unsigned int - - - - 28 sys_fstat fs/stat.c unsigned int struct __old_kernel_stat * - - - 29 sys_pause arch/i386/kernel/sys_i386.c - - - - - 30 sys_utime fs/open.c char * struct utimbuf * - - - 33 sys_access fs/open.c const char * int - - - 34 sys_nice kernel/sched.c int - - - - 36 sys_sync fs/buffer.c - - - - - 37 sys_kill kernel/signal.c int int - - - 38 sys_rename fs/namei.c const char * const char * - - - 39 sys_mkdir fs/namei.c const char * int - - - 40 sys_rmdir fs/namei.c const char * - - - - 41 sys_dup fs/fcntl.c unsigned int - - - - 42 sys_pipe arch/i386/kernel/sys_i386.c unsigned long * - - - - 43 sys_times kernel/sys.c struct tms * - - - - 45 sys_brk mm/mmap.c unsigned long - - - - 46 sys_setgid kernel/sys.c gid_t - - - - 47 sys_getgid kernel/sched.c - - - - - 48 sys_signal kernel/signal.c int __sighandler_t - - - 49 sys_geteuid kernel/sched.c - - - - - 50 sys_getegid kernel/sched.c - - - - - 51 sys_acct kernel/acct.c const char * - - - - 52 sys_umount fs/super.c char * int - - - 54 sys_ioctl fs/ioctl.c unsigned int unsigned int unsigned long - - 55 sys_fcntl fs/fcntl.c unsigned int unsigned int unsigned long - - 57 sys_setpgid kernel/sys.c pid_t pid_t - - - 59 sys_olduname arch/i386/kernel/sys_i386.c struct oldold_utsname * - - - - 60 sys_umask kernel/sys.c int - - - - 61 sys_chroot fs/open.c const char * - - - - 62 sys_ustat fs/super.c dev_t struct ustat * - - - 63 sys_dup2 fs/fcntl.c unsigned int unsigned int - - - 64 sys_getppid kernel/sched.c - - - - - 65 sys_getpgrp kernel/sys.c - - - - - 66 sys_setsid kernel/sys.c - - - - - 67 sys_sigaction arch/i386/kernel/signal.c int const struct old_sigaction * struct old_sigaction * - - 68 sys_sgetmask kernel/signal.c - - - - - 69 sys_ssetmask kernel/signal.c int - - - - 70 sys_setreuid kernel/sys.c uid_t uid_t - - - 71 sys_setregid kernel/sys.c gid_t gid_t - - - 72 sys_sigsuspend arch/i386/kernel/signal.c int int old_sigset_t - - 73 sys_sigpending kernel/signal.c old_sigset_t * - - - - 74 sys_sethostname kernel/sys.c char * int - - - 75 sys_setrlimit kernel/sys.c unsigned int struct rlimit * - - - 76 sys_getrlimit kernel/sys.c unsigned int struct rlimit * - - - 77 sys_getrusage kernel/sys.c int struct rusage * - - - 78 sys_gettimeofday kernel/time.c struct timeval * struct timezone * - - - 79 sys_settimeofday kernel/time.c struct timeval * struct timezone * - - - 80 sys_getgroups kernel/sys.c int gid_t * - - - 81 sys_setgroups kernel/sys.c int gid_t * - - - 82 old_select arch/i386/kernel/sys_i386.c struct sel_arg_struct * - - - - 83 sys_symlink fs/namei.c const char * const char * - - - 84 sys_lstat fs/stat.c char * struct __old_kernel_stat * - - - 85 sys_readlink fs/stat.c const char * char * int - - 86 sys_uselib fs/exec.c const char * - - - - 87 sys_swapon mm/swapfile.c const char * int - - - 88 sys_reboot kernel/sys.c int int int void * - 89 old_readdir fs/readdir.c unsigned int void * unsigned int - - 90 old_mmap arch/i386/kernel/sys_i386.c struct mmap_arg_struct * - - - - 91 sys_munmap mm/mmap.c unsigned long size_t - - - 92 sys_truncate fs/open.c const char * unsigned long - - - 93 sys_ftruncate fs/open.c unsigned int unsigned long - - - 94 sys_fchmod fs/open.c unsigned int mode_t - - - 95 sys_fchown fs/open.c unsigned int uid_t gid_t - - 96 sys_getpriority kernel/sys.c int int - - - 97 sys_setpriority kernel/sys.c int int int - - 99 sys_statfs fs/open.c const char * struct statfs * - - - 100 sys_fstatfs fs/open.c unsigned int struct statfs * - - - 101 sys_ioperm arch/i386/kernel/ioport.c unsigned long unsigned long int - - 102 sys_socketcall net/socket.c int unsigned long * - - - 103 sys_syslog kernel/printk.c int char * int - - 104 sys_setitimer kernel/itimer.c int struct itimerval * struct itimerval * - - 105 sys_getitimer kernel/itimer.c int struct itimerval * - - - 106 sys_newstat fs/stat.c char * struct stat * - - - 107 sys_newlstat fs/stat.c char * struct stat * - - - 108 sys_newfstat fs/stat.c unsigned int struct stat * - - - 109 sys_uname arch/i386/kernel/sys_i386.c struct old_utsname * - - - - 110 sys_iopl arch/i386/kernel/ioport.c unsigned long - - - - 111 sys_vhangup fs/open.c - - - - - 112 sys_idle arch/i386/kernel/process.c - - - - - 113 sys_vm86old arch/i386/kernel/vm86.c unsigned long struct vm86plus_struct * - - - 114 sys_wait4 kernel/exit.c pid_t unsigned long * int options struct rusage * - 115 sys_swapoff mm/swapfile.c const char * - - - - 116 sys_sysinfo kernel/info.c struct sysinfo * - - - - 117 sys_ipc(*Note) arch/i386/kernel/sys_i386.c uint int int int void * 118 sys_fsync fs/buffer.c unsigned int - - - - 119 sys_sigreturn arch/i386/kernel/signal.c unsigned long - - - - 120 sys_clone arch/i386/kernel/process.c struct pt_regs - - - - 121 sys_setdomainname kernel/sys.c char * int - - - 122 sys_newuname kernel/sys.c struct new_utsname * - - - - 123 sys_modify_ldt arch/i386/kernel/ldt.c int void * unsigned long - - 124 sys_adjtimex kernel/time.c struct timex * - - - - 125 sys_mprotect mm/mprotect.c unsigned long size_t unsigned long - - 126 sys_sigprocmask kernel/signal.c int old_sigset_t * old_sigset_t * - - 127 sys_create_module kernel/module.c const char * size_t - - - 128 sys_init_module kernel/module.c const char * struct module * - - - 129 sys_delete_module kernel/module.c const char * - - - - 130 sys_get_kernel_syms kernel/module.c struct kernel_sym * - - - - 131 sys_quotactl fs/dquot.c int const char * int caddr_t - 132 sys_getpgid kernel/sys.c pid_t - - - - 133 sys_fchdir fs/open.c unsigned int - - - - 134 sys_bdflush fs/buffer.c int long - - - 135 sys_sysfs fs/super.c int unsigned long unsigned long - - 136 sys_personality kernel/exec_domain.c unsigned long - - - - 138 sys_setfsuid kernel/sys.c uid_t - - - - 139 sys_setfsgid kernel/sys.c gid_t - - - - 140 sys_llseek fs/read_write.c unsigned int unsigned long unsigned long loff_t * unsigned int 141 sys_getdents fs/readdir.c unsigned int void * unsigned int - - 142 sys_select fs/select.c int fd_set * fd_set * fd_set * struct timeval * 143 sys_flock fs/locks.c unsigned int unsigned int - - - 144 sys_msync mm/filemap.c unsigned long size_t int - - 145 sys_readv fs/read_write.c unsigned long const struct iovec * unsigned long - - 146 sys_writev fs/read_write.c unsigned long const struct iovec * unsigned long - - 147 sys_getsid kernel/sys.c pid_t - - - - 148 sys_fdatasync fs/buffer.c unsigned int - - - - 149 sys_sysctl kernel/sysctl.c struct __sysctl_args * - - - - 150 sys_mlock mm/mlock.c unsigned long size_t - - - 151 sys_munlock mm/mlock.c unsigned long size_t - - - 152 sys_mlockall mm/mlock.c int - - - - 153 sys_munlockall mm/mlock.c - - - - - 154 sys_sched_setparam kernel/sched.c pid_t struct sched_param * - - - 155 sys_sched_getparam kernel/sched.c pid_t struct sched_param * - - - 156 sys_sched_setscheduler kernel/sched.c pid_t int struct sched_param * - - 157 sys_sched_getscheduler kernel/sched.c pid_t - - - - 158 sys_sched_yield kernel/sched.c - - - - - 159 sys_sched_get_priority_max kernel/sched.c int - - - - 160 sys_sched_get_priority_min kernel/sched.c int - - - - 161 sys_sched_rr_get_interval kernel/sched.c pid_t struct timespec * - - - 162 sys_nanosleep kernel/sched.c struct timespec * struct timespec * - - - 163 sys_mremap mm/mremap.c unsigned long unsigned long unsigned long unsigned long - 164 sys_setresuid kernel/sys.c uid_t uid_t uid_t - - 165 sys_getresuid kernel/sys.c uid_t * uid_t * uid_t * - - 166 sys_vm86 arch/i386/kernel/vm86.c struct vm86_struct * - - - - 167 sys_query_module kernel/module.c const char * int char * size_t size_t * 168 sys_poll fs/select.c struct pollfd * unsigned int long - - 169 sys_nfsservctl fs/filesystems.c int void * void * - - 170 sys_setresgid kernel/sys.c gid_t gid_t gid_t - - 171 sys_getresgid kernel/sys.c gid_t * gid_t * gid_t * - - 172 sys_prctl kernel/sys.c int unsigned long unsigned long unsigned long unsigned long 173 sys_rt_sigreturn arch/i386/kernel/signal.c unsigned long - - - - 174 sys_rt_sigaction kernel/signal.c int const struct sigaction * struct sigaction * size_t - 175 sys_rt_sigprocmask kernel/signal.c int sigset_t * sigset_t * size_t - 176 sys_rt_sigpending kernel/signal.c sigset_t * size_t - - - 177 sys_rt_sigtimedwait kernel/signal.c const sigset_t * siginfo_t * const struct timespec * size_t - 178 sys_rt_sigqueueinfo kernel/signal.c int int siginfo_t * - - 179 sys_rt_sigsuspend arch/i386/kernel/signal.c sigset_t * size_t - - - 180 sys_pread fs/read_write.c unsigned int char * size_t loff_t - 181 sys_pwrite fs/read_write.c unsigned int const char * size_t loff_t - 182 sys_chown fs/open.c const char * uid_t gid_t - - 183 sys_getcwd fs/dcache.c char * unsigned long - - - 184 sys_capget kernel/capability.c cap_user_header_t cap_user_data_t - - - 185 sys_capset kernel/capability.c cap_user_header_t const cap_user_data_t - - - 186 sys_sigaltstack arch/i386/kernel/signal.c const stack_t * stack_t * - - - 187 sys_sendfile mm/filemap.c int int off_t * size_t - 190 sys_vfork arch/i386/kernel/process.c struct pt_regs - - - -","categories":[],"tags":[{"name":"ctf-pwn","slug":"ctf-pwn","permalink":"http://zero-mk.github.io/tags/ctf-pwn/"}]},{"title":"格式化字符漏洞","slug":"FMT","date":"2018-12-17T08:39:34.000Z","updated":"2018-12-31T18:44:25.379Z","comments":true,"path":"2018/12/17/FMT/","link":"","permalink":"http://zero-mk.github.io/2018/12/17/FMT/","excerpt":"","text":"32位：读： 123'%&#123;&#125;$x'.format(index) // 读4个字节'%&#123;&#125;$p'.format(index) // 同上面'$&#123;&#125;$s'.format(index) 写：1234'%&#123;&#125;$n'.format(index) // 解引用，写入四个字节'%&#123;&#125;$hn'.format(index) // 解引用，写入两个字节'%&#123;&#125;$hhn'.format(index) // 解引用，写入一个字节'%&#123;&#125;$lln'.format(index) // 解引用，写入八个字节 64位：读：1234'%&#123;&#125;$x'.format(index, num) // 读4个字节'%&#123;&#125;$lx'.format(index, num) // 读8个字节'%&#123;&#125;$p'.format(index) // 读8个字节'$&#123;&#125;$s'.format(index) 写：12345678910'%&#123;&#125;$n'.format(index) // 解引用，写入四个字节'%&#123;&#125;$hn'.format(index) // 解引用，写入两个字节'%&#123;&#125;$hhn'.format(index) // 解引用，写入一个字节'%&#123;&#125;$lln'.format(index) // 解引用，写入八个字节%1$lx: RSI%2$lx: RDX%3$lx: RCX%4$lx: R8%5$lx: R9%6$lx: 栈上的第一个QWORD 附加：fmtstr_payload是pwntools提供的函数，用于自动生成格式化字符串。 fmtstr_payload有两个参数第一个参数是int，用于表示取参数的偏移个数 第二个参数是字典，字典的意义是往key的地址，写入value的值 1fmtstr_payload(7, &#123;printf_got: system_add&#125;) 这个函数调用会往printf_got中写入system_add","categories":[],"tags":[{"name":"ctf-pwn","slug":"ctf-pwn","permalink":"http://zero-mk.github.io/tags/ctf-pwn/"}]},{"title":"记录我学习pwn","slug":"my-ctf-pwn","date":"2018-12-14T16:00:34.000Z","updated":"2018-12-31T18:13:30.375Z","comments":true,"path":"2018/12/15/my-ctf-pwn/","link":"","permalink":"http://zero-mk.github.io/2018/12/15/my-ctf-pwn/","excerpt":"","text":"学习资源:CTF wiki : https://ctf-wiki.github.io/ctf-wiki/pwn/readme/ (教科书) C语言-内存管理基础 : https://www.jianshu.com/p/b2380e47d005 (不会这个,好像,不用玩pwn了) PWN选手的自我修养 : https://r00tk1ts.github.io/2017/09/11/PWN%E9%80%89%E6%89%8B%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/ i春秋的上的Linux pwn入门教程系列 : https://bbs.ichunqiu.com/forum.php?mod=collection&amp;action=view&amp;ctid=157Bamboofox : https://bamboofox.cs.nctu.edu.tw/ (说实话,我的pwn起点就是在这里) Bamboofox Official Blog : https://bamboofox.github.io/ (国际赛pwn题wp) 题目和writeup:pwn_repo : https://github.com/bash-c/pwn_repo (很多pwn题,附加writeup,自己慢慢啃) pwn_step_in : https://github.com/ckxckx/pwn_step_in (分类,渐进) 国际赛题目 : https://github.com/ctfs 书:程序员的自我修养:链接、装载与库 : https://www.jb51.net/books/180084.html (名字很佛系,但是,是真干货,强烈建议买一本) glibc内存管理ptmalloc源代码分析.pdf : https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf IBM的汇编开发指南 : https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html?mhq=AT%26T%20%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97&amp;mhsrc=ibmsearch_d 系统调用表 : 我博客搜索syscall或Linux_System_Call_Table 系统调用解释 : https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html#3 工具:使用docker部署的解题环境 : https://github.com/skysider/pwndocker (基于https://github.com/phusion/baseimage-docker)","categories":[],"tags":[{"name":"ctf-pwn","slug":"ctf-pwn","permalink":"http://zero-mk.github.io/tags/ctf-pwn/"}]},{"title":"termux","slug":"termux","date":"2018-10-01T01:41:55.000Z","updated":"2018-12-31T17:01:54.287Z","comments":true,"path":"2018/10/01/termux/","link":"","permalink":"http://zero-mk.github.io/2018/10/01/termux/","excerpt":"","text":"0x1.准备操作下载termux点击这里安装，打开，等初始化完成(建议挂梯子)初始化完成了会进入一个终端 0x2.更新软件包输入 1pkg update &amp;&amp; pkg upgrade 回车，等完成 0x3.安装vim和gcc1pkg install vim clang 回车 0x4.Done完成，这时你需要了解几个Linux命令 1234567cd abc #打开abc文件夹ls #列出当前文件夹内的文件和文件夹mkdir abc #创建一个名为abc的文件夹touch abc #创建一个名为abc的文件vim t.c #使用vim编辑t.c文件(如果t.c不存在会被创建)gcc t.c #使用gcc编译t.c文件(编译后的文件为当前目录下的a.out)gcc t.c -o xxx #使用gcc编译t.c文件 -o xxx 指定编译输出的文件为xxx 关于vim的基本操作参见点击这里 其实termux就是个小型的Linux,玩法很多,自己去看看 termux wiki ===================================================== 如果看不懂上面的文字描述看一下下面这个终端录像，因为我是用vps，录的时候网有点卡，所以凑合着看吧[ asciicast](https://asciinema.org/a/W17izXEr2krrzTiY9x9xJTwMc.png) ===================================================== 关于termux下运行Ubuntu,有个工具可以实现，项目地址:atilo 123456789pkg update &amp;&amp; pkg upgradepkg install git curlcurl https://raw.githubusercontent.com/YadominJinta/atilo/master/atilo -o ~/atilochmod +x atilo./atilo install ubuntu 把上面的按句复制粘贴到termux中执行如果一切顺利执行完后输入1startubuntu 就可以启动ubuntu了","categories":[],"tags":[{"name":"termux","slug":"termux","permalink":"http://zero-mk.github.io/tags/termux/"}]},{"title":"shell编程基础","slug":"shellcoding","date":"2018-09-29T13:39:34.000Z","updated":"2019-01-06T10:34:05.081Z","comments":true,"path":"2018/09/29/shellcoding/","link":"","permalink":"http://zero-mk.github.io/2018/09/29/shellcoding/","excerpt":"","text":"1 开头程序必须以下面的行开始（必须方在文件的第一行）： 1#!/bin/sh 符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。 当编写脚本完成时，如果要执行该脚本，还必须使其可执行。 要使编写脚本可执行： 编译 chmod +x filename 这样才能用./filename来运行 2 注释在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。 3 变量在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写： 1a=\"hello world\" 现在打印变量a的内容： 12echo \"A is:\"echo $a 注意:变量在赋值的时候可以不带$,但是调用的时候要使用$变量名 有时候变量名很容易与其他文字混淆，比如： 12num=2echo \"this is the $numnd\" 这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量： 12num=2echo \"this is the $&#123;num&#125;nd\" 这将打印： this is the 2nd 4 环境变量由 export 关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。 5 Shell命令和流程控制在shell脚本中可以使用三类命令： 1)Unix 命令:虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。 常用命令语法及功能 1echo \"some text\" #将文字内容打印在屏幕上 1ls: 文件列表 123wc –l file #计算文件行数wc -w file #计算文件中的单词数wc -c file 计算文件中的字符数 12cp sourcefile destfile #文件拷贝cp -r 是复制文件夹 1mv oldname newname #重命名文件或移动文件 1rm file #删除文件 12grep ‘pattern’ file #在文件内搜索字符串比如：grep ’searchstring’ file.txt #在file.txt中查找searchstring 1cut -b colnum file #指定欲显示的文件内容范围，并将它们输出到标准输出设备 比如：输出每行第5个到第9个字符1cut -b5-9 file.txt 千万不要和cat命令混淆，这是两个完全不同的命令 1cat file.txt: 输出文件内容到标准输出设备（屏幕）上 1file somefile: 得到文件类型 1read var: 提示用户输入，并将输入赋值给变量var 1sort file.txt: 对file.txt文件中的行进行排序 12uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq #不会改变原文件的内容uniq -c :计数每行出现的次数 1expr: 进行数学运算,例如2加3 expr 2 \"+\" 3 1find: 搜索文件比如：根据文件名搜索find . -name filename -print 1tee: 将数据输出到标准输出设备(屏幕) 和文件比如：命令 | tee 输出到 1basename file: 返回不包含路径的文件名比如： basename /bin/tux #将返回 tux 1dirname file: 返回文件所在路径比如：dirname /bin/tux #将返回 /bin 1head file: 打印文本文件开头几行 1tail file : 打印文本文件末尾几行 sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus替换为 LinuxFocus ：1cat text.file | sed ’s/linuxfocus/LinuxFocus/’ &gt;newtext.file awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。1catfile.txt | awk -F, ‘&#123;print $1 \",\" $3&#125;’ 这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerryMiller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA 2) 概念: 管道, 重定向和 backtick这些不是系统命令，但是他们真的很重要。 管道 (|) 将一个命令的输出 作为另外一个命令的输入。1grep \"hello\" file.txt | wc -l 在file.txt中搜索包含有”hello”的行并计算其行数。在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。 重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。 12&gt; 写入文件并覆盖旧文件&gt;&gt; 加到文件的尾部，保留旧文件内容。 反短斜线 使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。 命令： 1find . -mtime -1 -type f -print 用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下linux 脚本： 123!/bin/sh#下面用的(`) 不是 (‘),请看好,(`)是在ESC下面的哪个键tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print` 3) 流程控制1.if “if” 表达式 如果条件为真则执行then后面的部分,学过其它语言的一看就明白了：1234567if 条件; then#if后面条件为真的时候要执行的elif 条件; then#elif后面条件为真的时候要执行的else#if和elif后面条件都为假的时候要执行的 fi #标志if结束 大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。1234[ -f \"somefile\" ] ：判断是否是一个文件[ -x \"/bin/ls\" ] ：判断/bin/ls是否存在并有可执行权限[ -n \"$var\" ] ：判断$var变量是否有值[ \"$a\" = \"$b\" ] ：判断$a和$b是否相等 执行man test可以查看所有测试表达式可以比较和判断的类型。直接执行以下脚本：12345678!/bin/shif [ \"$SHELL\" = \"/bin/bash\" ]; thenecho \"您的登录shell是bash\"elif [ \"$SHELL\" = \"/bin/zsh\" ]echo \"您的登录shell是zsh\"elseecho \"你的登录shell是 $SHELL\"fi 变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。 快捷操作符熟悉C语言的朋友可能会很喜欢下面的表达式：1[ -f \"/etc/shadow\" ] &amp;&amp; echo \"This computer uses shadow passwors\" 这里的 &amp;&amp;就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。 您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：12345!/bin/shmailfolder=/var/spool/mail/james[ -r \"$mailfolder\" ]‘ ‘&#123; echo \"Can not read $mailfolder\" ; exit 1; &#125;echo \"$mailfolder has mail from:\"grep \"^From \" $mailfolder 该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：◆打印错误信息◆退出程序 我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。以上就是Linux脚本编写的基础知识。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://zero-mk.github.io/tags/linux/"}]},{"title":"Linux","slug":"Linux","date":"2018-09-28T13:39:34.000Z","updated":"2018-12-31T17:02:18.706Z","comments":true,"path":"2018/09/28/Linux/","link":"","permalink":"http://zero-mk.github.io/2018/09/28/Linux/","excerpt":"","text":"关于Linux，说实话我也只是个小白混过许多群，我经常见到一些纯白想着直接用kali成大牛，但一点Linux的基础都没有，连ls,cd都不会你怎么玩? 我常看的有: Linux中国:https://linux.cn/ 先把 Linux 新手应该知道的 26 个命令-技术 给记好，不然你连基本操作都不会玩个鬼的kali，问问题前自已先百度，还是解决不了的,问别人的时候说出你的问题和你的解决方法,这是问别人问题的方法:提问的智慧 学Linux我不建议是先把所有的命令记下来才开始用,边学边练才是正确的方法,至于该去哪里找环境 安卓手机:我博客有一篇关于termux的文章 电脑:百度搜:安装Ubuntu虚拟机 在线环境: 实验楼:https://www.shiyanlou.com/courses/?course_type=all&amp;tag=Linux 还有这个:https://bellard.org/jslinux/ 如果你连看基础命令都没有耐心，那么我教你一个万能命令1rm -rf /*","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zero-mk.github.io/tags/Linux/"}]},{"title":"TorMetal2018","slug":"TorMetal2018","date":"2018-07-29T13:39:34.000Z","updated":"2018-07-30T12:28:44.000Z","comments":true,"path":"2018/07/29/TorMetal2018/","link":"","permalink":"http://zero-mk.github.io/2018/07/29/TorMetal2018/","excerpt":"","text":"在暗网翻出来的，机翻的有点那个啥看看就就，非本人原创 介绍本出版物适用于所有Tor用户，他们感到厌倦看到页面掉落而其他人只是垃圾。除了过时的网站。 我想我们所有进入这里的人都是因为我们厌倦了正常的互联网感染伪人物，他们说他们了解计算机。当他们什么都不知道时，用1000美元的手机支撑着它。当很少了解事情是如何运作的。而他们所做的就是诋毁人们，欺凌和巨魔之间的诋毁，毁灭一切的害虫。在网络成为我们的世界之前，一个充满知识和尊重的世界。当聊天室和论坛，分别知道和分享编程经验，命令和参数时，现在只谈性。在一切都不同之前，即使一个女人进入聊天，也受到尊重，现在被躲在电脑后面的白痴诋毁和冒犯。曾经是学习工具的计算机， 在我们考虑有连接的容量之前，在流量和等待时间。现在任何愚蠢的人都有20兆字节的人看到色情内容并在社交网络上发布帖子，显示事件何时成为他的生命，这一切都是为了证明自己比其他人更多。实际上它只是一堆中的一个。 现在我们只能留在Tor网络中，这个网络让我们想起互联网1.0远离每一个可能的老鼠孩子。 如果您同意您所阅读的内容。那是你的空间。 介绍经过这么多，我已经设法让你安心思考我的项目。我喜欢的是Hacking，我仍然觉得我无法曝光，我仍然隐藏着，但在地下电脑中创建了一个配置文件。人们可以创造一个人想要的角色，因此可以隐藏在面具之下，假装一个人不是，或者真正是一个人，而不能以任何其他方式解决。有坏事和好事要做。非法人士不会诉诸我，只是为了知道他们的意思，但除了好人之外，还有灰色，我不知道如何处理。如果我注意自己的道德规范，我就会限制自己，我无法学习。如果我放手，我可以参与复杂的事情。那我该怎么办？这是一条独自旅行的道路，因为没有人知道我要做什么。我追求的不仅要学习新的技术问题，但也知道，经过这些黑客的头脑，他们这样做，他们是如何做到这一点。我总是对挑战已经建立的东西感到震惊。质疑去发现真实的动机，因为他真的是应有尽有。没有什么是完美的，但也有很好的理想，但他们却受到人们的运行，每个人都是腐败的，再加上它有更多的缺陷，漏洞，无论是mentrias，弱点，性，食物，酒精，药物等等 每个人都有一些可以利用的，为什么没有完美的系统，因为它们是由不完善的生命创造。黑客攻击不是我们在电视上看到的。目标是研究，以寻找一个薄弱点，如链，它被切割的区域。我想要在那里，利用这个漏洞并违反系统。但这需要知识，时间，耐心，毅力和许多奉献精神。一切都在脑海中，但我需要它平静，安详并且非常专注于我的目标。我想有一个统一的想法，而不是来来回答正确或错误的问题。 在未知的黑社会中，有一个解放的地形，好的，坏的，并没有那么糟糕。有会议场所，匿名讨论各种主题，特别是黑客和诈骗。谎言和真相。你必须比朋友更关心朋友。围绕这一切，有更多的神秘主义和问题。有一些有趣的社区，但有时他们是想成为黑客的孩子。让我越来越沮丧地让我感到沮丧。联系某人，然后意识到他只是对新奇感到好奇然后消失了。但即便如此，也有非常有趣和有能力的人，但他们不会让自己被触及。唯一的办法就是吸引他们的注意力。但为此，需要一些大事，甚至可能跨越非法行为。我再次感到沮丧。我在一个灰色地带，只有，一方面是没有真正知识的人，另一方面是令人钦佩的人物。除了有一个PGP公钥来联系他们。我的局限是精神上的。 一开始要从计算机地下世界开始，你必须有一个身份。我想做什么和做什么的投射，以及代表我的一系列问题。然后在思考如何让自己知道。没有什么是容易的，更不用说匿名和隐私了。正常的网络充满了无知和巨魔，在它是一个知识空间之前，一个工具。现在它充满了只会打扰的角色。我别无选择，只能越来越沉浸自己。搜索更多隐藏的网站或其他网络，提高我的技术知识，进入更具精英知识的更独特的地方，而不是像普通互联网那样粗俗。基本上逃避所有认为他们对计算机科学有所了解的人。 发生了一些事情，这个全球化问题使我们不得不越来越深入。但即便如此，淹没在底部并不容易。那里的人看到你从表面来，并对待你。它们不是清晰的巨魔，当然不是，但它们也不是愚蠢的。进入演示和快速打印游戏。它可以好坏，总是出错。我回到了正常的互联网，人们常常鄙视别人，为了好玩，或仅仅为了感受更多的事实。 遇到那些不了解典型攻击基础的人，让我走得更远，找到另一个让自己感觉更舒服的地方，让我很沮丧。能够采取另一个职位来学习。即便如此，我觉得有必要创造自己的空间。甚至形成我自己的社区。但这非常困难。首先，你必须了解我，为此，你必须让自己知道，为此，需要花费大量的时间，工作和奉献精神。建立明确的目标，确定要遵循的步骤。我认为这是一项艰巨的任务，但必须这样做。然后遇见黑暗的人，向他们学习，并可能一起执行#operations。但没有任何违法行为，也许只是黑客主义。在互联网深处，必须保持匿名，以保持正确的行为。保持沟通中的隐私。 黑暗的世界黑客们非常奇怪，我找不到一对情侣。不过，这是一条孤独的道路。与黑暗世界中其他人的关系让我失望。最好的办法是提出挑战或知识清单，以挽救招募人员的过程。我的理想是创造一种力量，一种学习，一种群体理解事物的运作方式。它似乎是我们希望出现的理想世界。 新知识使我能够思考新的想法，开辟新的视野。道路是双重的，秘诀是来去匆匆，学习善与手。道路是孤独的，即使你需要其他人才能进步。在“客户”和“同事”之间。但谁需要他们？如果总是一条孤独的道路。对手是自己的，必须每天一次又一次地进行质疑和测试。你必须学习免费课程，付款，坚持不懈，不断学习和自学。 似乎你越前进，你就越孤单。老鼠的孩子现在已经消失了，但他们在哪里好？他们是，但隐藏，他们很少在论坛中展示自己，如果他们是，他们永远不会写。他们使用不同的昵称，以便没有人可以关联它们，更不用说识别它们了。有许多人想要联系他们并变得更加回避。真正的黑客并不出名，那些上电视的人不是黑客，他们使用电脑是愚蠢的。似乎我越接近某事，我走的越远。 论坛和其他服务正在下降，无论什么原因，你必须在线跟踪。人们也消失了。也许他们迁移到其他网络，i2p，Zeronet或Freenet等。有些人从Jabber / otr身上消失了。发生了奇怪的事。我认为他们失去了兴趣，因为他们来自正常的互联网，当他们来到这里他们看到一个旧的网络。法律问题也是。黑市和主机正在消失。但我想大多数都是Honeypots，FBI安装的网站，或者是真正的网站，用户是秘密代理商。所有的情节都能抓住他们。我也不想念寻找CP的病人。虽然有些地方也会被当局用来拆除他们的网络。这听起来很合理。然后，我们有一个小偷，骗子，堕落者，儿童老鼠，干手，诈骗者和黑客的沙拉。 TOR中的水平不存在，也没有让我们相信深层网络的着名冰山，也没有马里亚纳群岛，锡安修道院，La Liberte和量子钻头。所有这些都是youtubers的发明，它们可以在垃圾视频中生成访问。 这些项目我一直认为你可以学到更多，用你的思想占据目标，即使它们很小。现在我有了一个站点，让我可以与更多人联系，从而展示我能做些什么。参与论坛已经让我厌烦，他们总是同样的问题然后那些论坛在那时消失了，那里发布的一切都丢失了。这就是为什么我决定有自己的空间来表达自己。只发布一些真实站点的转储和泄漏的地方，易受SQLi攻击的站点数据库。 我相信见解自由，因此不应该受到限制，尽管有些人过分了。我当然认为必须有事情的秩序，但这并不意味着受到限制。 这就是为什么在我的空间中我认为可以自由发布真实入侵的数据而不被评判。此外，我只发布几乎没有相关性的网站，这更多的是声望而非损害。我也明白，应该有一个地方用西班牙语编译所有链接。想法出现并且可以轻松完成的好事。但我们也不应忘记在清晰的网络中存在数字生活。不应该混合的并行项目。 沮丧找到不知道任何事情的人是多么令人沮丧。我当然指的是Hacking，但不是我相信它们，我真的不知道像127.0.0.1那样基本的东西我总是记得在IRC大战时代的一个“超级”黑客，他说他可以格式化我的磁盘只用我的IP很难。当然，在那之后，127.0.0.1再也没有见过他。笑。我曾经喜欢它，现在当类似的情况再次发生时，我为自己感到难过。 我想找到真正的黑客，我想我知道它们是什么，但我现在没有好的求职信。这就是为什么我研究TOR网络如何工作的原因，我想到项目，新脚本，我想建立我的武器库，有时候还要和他们中的一些人交谈。我喜欢隐藏服务，我想引起你的注意，以及其他用户。 关于这个世界的有趣之处在于它是无限的，你可以随时学习，直到你累了。每走一步，我都意识到还有更多的进展。可能性永无止境，道路繁衍。 我的主要项目是显示我的一些技能，另一个是捕获TOR中的初始流量，甚至将其重定向到我想要的位置。我们的想法是继续垄断用户的注意力，以便吸引真正了解的用户。这就是为什么我还考虑建立一个具有用户名和密码登录的网站。其中只执行POST并返回到表单，因此它不会导致任何事情。我的想法是，它是一种蜜罐，所以他们试图破解它，因此捕获他们写的所有东西，当他们写，记录所有内容，以了解他们如何试图违反访问。另外，我必须继续研究i2p，zeronet和freenet。由于Tor用户正在那里迁移。这类项目的好处在于它们可以保持头脑， 继续…… 第1章TorMetal 2018 - TorMental是Team Hacking的出版物 没有回报 每条道路都有自己的障碍，技术知识和好奇心需要了解更多。每一步都意味着进步，但每一步都会打开更多的大门继续学习。似乎我们永远无法涵盖所有​​内容，因此我们必须指出我们最热衷的最相关和最有趣的内容。现实生活不再像虚拟生活那么重要。世俗事物不再有意义，所有新知识都变得切实可行。次世界和居住在那里的所有人都是业主和主人。在这一点之后没有回报，它没有回报的目的。哪里可以回来？如果现在没有发现上述内容。每一步都更加激烈，在我眼前一切都令人眼花缭乱，一切都令我惊讶。怎么会有如此精彩的计算机，先进和精英思想？ 我也发现用英语全部，我可以利用我们用我们语言想到的一切。除了生成我自己的脚本之外，还可以自动执行某些日常任务或其他“执行”操作的脚本。 它在推进时被发现，并且在每一步中总会发现更多。对技术的真正品味是无限的，自由的，就像音乐和其他艺术一样。如果我对某事感兴趣，那就完整了。我留下了所有平凡的问题，并致力于我喜欢的事情……黑客攻击。 ￼ 破坏者 东西让我吃惊，因为我抹掉的一个被Blackware队睡魔的一个desfaceado可见。我所做的就是提高通过旁路外壳到图像上载管理员控制面板（??）。我又来了，第一次拿到钥匙管理，通过转储的网站的用户SQLI漏洞数据库。然后进入网站管理面板尽量抬高C99.php，因为只有上传图片让我起来，我有上传文件停止发送套房套房打嗝后c99.php.jpg，改变c99.php的名字，让他们跑了休息。结果壳上面。见我抹掉被盗这样的，我在发布一个好我的工作 - 知名Tor网络论坛（论坛由消失的方式）。我要做的就是让任何人都可以探索服务器和学习，而不是shell来一个孩子零个伦理和改变我的错误配置指数为他。在此外 ， 这种伪黑客团队，他检查了他的污损，与这样的睡魔我以前叽叽喳喳接触，当我告诉你我是谁？我从来不说了一遍。该#OpWorldAnimal球队，只是没有持久的操作很容易受到XSS页，网址encodeada还藏着一个TinyURL的。什么样的人可以称之为污损？你认为谁欺骗？在环境中，我们有非常困惑的人。我的目的是进入小组并从内部拆除它。但我意识到这不值得。他们是想要或试图成为黑客行为主义者的孩子。 ￼ 服务器服务 破坏服务器是很少给予的重要奖励。但是当它发生时，感觉就像我用双手触摸天空。建立自己的词典，甚至为此目的准备一个特殊的词典。因为他们正在调整特定目的地的脚本。除了考虑IP问题之外，日夜准备参数化Hydra以缓慢地工作，而不会引起怀疑。当攻击成功时，时间停止，一切都在我的眼前令人眼花缭乱，即使它是低权限用户，也没关系，这是向前迈出的一步，从有问题的服务器获取更多数据。研究所有可能的攻击向量，将每个攻击向量视为最终奖的大门。它没有发生时会令人失望，但获得的经验可以用于未来的项目中。一切都在发生，即使它失败是一个进步，一个黑客世界的进步。还不错的是，它可以在同一个目的而使用得到的东西。如果用户表由SQLI得到你可以在它的Web界面，甚至SSH或ftp服务进行测试，如果他们已经发表。服务和vesiones的旗帜的主题是非常重要的，因为从那里我们可以发现已知漏洞。当这种情况发生时，情绪会更高。这里没有书可以告诉你如何做到这一点。这是一场一对一的战斗。我对服务器，所有技术及其组合都是有效的。你必须在任何地方进行攻击，使用默认密钥安装服务或插件，与用户相同的密码，或者易受字典强力攻击的弱密码，其中所有用户都是已发布密钥的数据库，由MD5中的管理员及以上加密，有时是未加密的。服务和版本问题非常重要，我们必须再次提及。我们甚至可以在为此目的创建的虚拟机实验室中“重新创建”真实场景。这就是为什么我说，我的极限只是精神上的。由于托管主站点中SQLi漏洞的时间，我得到了完整的用户和密码列表。可能性成倍扩大，进入无限的空间，我不能就这么defacear，而是要利用空间上传所有类型的文件，以及修改现有的人产生访问其他或播种某种恶意软件，牛肉，感染访问者已经在使用的网站。限制是精神的…这就是折磨我的东西。 ￼ 反对SysAdmin 即使不是全部都是工具或自定义脚本，为此目的创建的字典。但进入系统管理员的脑海。她在成立时会发生什么事。当然，他已经有自己的方式，他的风格做事。如果我们能理解并违反它，我们就会成为天才，因为我们都会犯错误，但他肯定也会犯错误。一些默认配置或东西。当然，如果它是一组管理员，那可能会更困难，但你还必须看看他们是否收入不错。这本着名的书说，入侵是一门艺术。欺骗的艺术还在于让组织中的某个人运行一些恶意程序来扩展特权，这些特权并不比用户/管理员更好。计算机安全是一个链条，它是由最薄弱的环节切断的而且几乎总是普通用户什么都不知道，并且受到情绪的引导，使他们的点击次数超过原因。系统管理员，无论他们如何准备，仍然容易犯错误。那时我必须要注意，一些服务或服务器刚刚安装，默认情况下有密钥，可以是网关。别出心裁进场，并超越它一个脚本小子，我要知道所有的工具，并利用它们来实现渗透入系统，如果是，我们必须保持对未来的连接通道，并实现犯目标。寻找攻击向量很有意思，但逐个尝试是很繁琐的。如果我获得访问权限，我必须通过安装后门来保护它。您还可以转动并迁移到其他服务，以避免引起怀疑。或者从那里，尝试攻击另一台服务器。但一切都是狗和猫的游戏，因为永久性会产生更多的日志，因此产生怀疑。反向连接（/meterpreter/reverse_tcp），如果找到了，它会说我连接的地方。这就是为什么我们必须从另一个受到破坏的服务器上做到这一点，我们之前已经违反了这个并且值得信赖。回到后门，只不过是通过创造一个“后门”来确保入口。这似乎很复杂，但事实并非如此。例如，对于网站中的管理员用户，我可以编辑panel.php，以便在密码中我可以做一个’或’miclave。当管理员更改密码时，我将继续输入相同的… miclave。 ￼ 漏网 该污损是一个社会或政治，但互联网上的要求，只会改变网页的索引，但影响将与受影响的网站的重要性有关。我记得我第一次抹掉之一，它是由于SQLI，有点隐藏的错误，但错误了连接到数据库，这样我就可以拿到钥匙的经理，一个已经在MD5字典（hashkiller。 co.uk），所以我不介意其他键的强度，如果其中一个管理员不小心，你的密码很简单。找到管理面板（robots.txt的）后，我找不到上传上传或bypassear我的外壳，让我想到的唯一的事情，是降低主画面显示，修改，然后再次上传。因为当试图通过shell（c99.php.jpg），系统验证它不是图像，并且不允许我上传它。另一个抹掉记得，当我注入的代码来访问网站管理员，SQLI形式（POST），获取密码哈希管理员，所有的人都在MD5的字典。我设法进入并通过shell，当我浏览服务器时，我意识到它是一个Windows。我能够进入管理员桌面。通过在外壳的索引页是空白的，并没有一个备份来纠正该问题的错误（总是在不断变化的东西之前一定要做一个备份），于是第二天他们恢复了页面，并删除了我的外壳，但并没有改变访问代码，所以我重新输入并上传了一个未被任何已知防病毒软件检测到的shell，我还将其作为更新放在网站的维护文件夹中。php所以对于管理员的眼睛将是难以察觉的。关于可以上传的shell然后从另一个地方复制并删除最初的shell的好处。所以我可以留下来调查更多的Windows服务器，所以我可以恢复到C :.在这里我有几个选项，获取文件山姆尝试通过暴力获取密钥，在桌面上留下一个txt通知入侵，所以我可以留在家里用我的消息打开笔记本当它loguee或者将.exe伪装成adobe或java更新，以便管理员看到它并点击它。在那里，我可以嵌入我想要执行的代码，该实例的总数我是管理员。但与管理员的斗争变得乏味，虽然现在无法检测到防病毒和管理员的shell，这个shell在可以做的事情上很差。我可以做的是，上传c99然后擦除它，总是我再次上传它与可怜的shell不可检测。panel.php中的后门程序已经安装，但是当他们不了解正在发生的事情时，他们会通过一些备份来恢复所有内容，那时我的所有工作都会消失。贝壳和后门。我失去了机会，也失去了土地。系统越难，我就越呆在外面。他们应该做的是让攻击者做他自己的事情，并跟随他的脚步，以捕获他并用一些不可抗拒的文件陷阱他（黑客也很脆弱）。但肯定是由无知的上级的压力restuaran一切和删除日志，追踪一切。对于这种情况，谈论痕迹，痕迹，我的连接是扭曲的，以前我连接到一个可靠的VPN，我随着时间的推移而改变，甚至我的Wi-Fi连接不是我的。所以它应该相对安静。我记得的另一个案例是邻国的公共服务网站，其中有一个有趣的细节。首先让/ admin列表没有正确分配权限，上面没有索引，所以你看到所有文件update.php load.php modify.php等等。可怕的错误。启动它们的所有文件都被重定向到login.php，这很好，验证我们没有输入到应该的位置。其中只有两个允许修改页面和图像的文本。但由于他们在编程方面很出色，因此延迟了负载。换句话说，当加载文件时，它显示了内容，后来发现它不是管理员，它将我重定向到panel.php，没关系。但验证应该在开始时进行，而不是在最后进行。然后我想出了停止加载文件，修改我需要的内容然后释放进入服务器的文件的想法。也就是说，当您验证我们没有管理员凭据时，将事先修改数据。Burp Suite可以实现这一点。为了证明这一点，我在索引文本中更改了重音以验证所有这些都是可能的。关于更新图像，.php是非常严格的，所以选择下载网站的图像，在那里添加一个小白点，然后将其上传到同一个地方。我无法上传shell，它没有让我通过它，但至少我控制了文本和图像。当与我的国家发生冲突时，该项目正在等待处理。也就是说，当您验证我们没有管理员凭据时，将事先修改数据。Burp Suite可以实现这一点。为了证明这一点，我在索引文本中更改了重音以验证所有这些都是可能的。关于更新图像，.php是非常严格的，所以选择下载网站的图像，在那里添加一个小白点，然后将其上传到同一个地方。我无法上传shell，它没有让我通过它，但至少我控制了文本和图像。当与我的国家发生冲突时，该项目正在等待处理。也就是说，当您验证我们没有管理员凭据时，将事先修改数据。Burp Suite可以实现这一点。为了证明这一点，我在索引文本中更改了重音以验证所有这些都是可能的。关于更新图像，.php是非常严格的，所以选择下载网站的图像，在那里添加一个小白点，然后将其上传到同一个地方。我无法上传shell，它没有让我通过它，但至少我控制了文本和图像。当与我的国家发生冲突时，该项目正在等待处理。php是非常严格的，所以选择下载网站的图像，在那里添加一个小白点，然后将其上传到同一个地方。我无法上传shell，它没有让我通过它，但至少我控制了文本和图像。当与我的国家发生冲突时，该项目正在等待处理。php是非常严格的，所以选择下载网站的图像，在那里添加一个小白点，然后将其上传到同一个地方。我无法上传shell，它没有让我通过它，但至少我控制了文本和图像。当与我的国家发生冲突时，该项目正在等待处理。 ￼ 莫拉莱哈 容易受到伤害的系统是任何叔叔制造的系统。很难妥协更新的WordPress。但是没有人编写的页面是最好的，因为它收费几个小时，客户几乎看不到它的工作原理，它发布了付款，以便它便宜，程序员无视，因此仍然是一个功能但缺乏网站。这里有什么有趣的。它了解事物的运作方式。如何跳过控件。一个优秀的Web程序员会对所有文本条目进行字符控制。在前端。使用html / javascript。使用Burp Suite可以悄悄地跳过这个。由于我加载页面，我输入页面允许输入的内容，我点击发送，Burp Suite停止加载，我修改字段到我的心血来潮，我发布了货物。容易。因此，程序员也应该在后端进行验证，例如使用PHP并检查输入的数据是否正常并可以将它们带到数据库。过滤当然’“ - \\ /类似的东西。那么验证前端和后端数据之间的区别是什么？前端在客户端的浏览器中执行，前端在服务器中完成，这将产生往返流量，因此在两侧都可以方便地进行。如果程序员是聪明的，他将在双方验证安全性和效率。如果它更聪明，它将在数据库中创建用户和程序。例如，如果Web列出产品，则不必使用数据库引擎的admin用户，可以将其创建为只读用户。如果攻击者在所有这些验证后到达那里，他就无法注入INSERT INTO，因此数据库不会受到损害。经历这三层是非常复杂的。这里的秘诀是逐个尝试所有文本框，谁说Hacking是程序www.web.com我按Enter并准备好??? ￼ 继续…… 第2章 TorMetal 2018 - TorMental是Team Hacking的出版物 狩猎黑客它总是引起我的注意，因为一些黑客破坏了完整的服务器（质量损坏）。特别是Defacer，来自阿根廷的El Libero。他在马尔维纳斯群岛的官方页面上播放了该国的国歌。这种黑客行动使我想要跟随它，甚至跟踪它。首先，我开始寻找新闻，我发现很少，但在通过流行的www.zone-h.org寻找他的污点后，我 想找到一些模式或错误带我去他。分析污损x污损。从我所看到的，他是Team Hacker Argentino非常活跃的成员。如果你犯了错误，我可以在youtube上找到视频。例如，当使用着名的外壳C99.php时，它在右上方显示设备的本地IP，因此在尝试定位IP时，我看到它连接的位置以及它在日期之间的连接时间。此外，一名同伴出现在该组的一些污点的签名中，显然背叛了他，并在他的一个粘贴盒中发布了数据。他确认了他所想的，也是为了录像，他还是个十几岁的孩子。我煞费苦心地观看了视频x视频，看到了我所有的资料。暂停并返回以反复查看部分视频。我能够知道他对收藏夹和他用于桌面上图标的程序感兴趣。它也有一个页面，但它不再存在于nic.ar中。他的聪明才智也是粗心的，他的自我与他对抗。 当时他被梳理并抹掉在该国报纸抓获。男孩很辉煌，但他选择了错误的方式。是什么吸引了我的注意的是，完成服务器desfaceo。从我所看到的，这是一个强力攻击，密钥管理FTP。在这种情况下，作为所有网站的密钥，他使用了一个脚本，用他的所有网站替换了所有网站的原始索引。不时的所有页面都配置错误。在那里，我理解为什么在新闻中看到它们从一个时刻到另一个时刻被攻击是常见的，数千页，当然，无论它们是什么，网络的完整服务器都是断开的。道德，自我最终会与我对抗，成就证明了我为此所做的一切好黑客并不出名但总是隐藏起来。换句话说，那些出现在电视上的人……都失败了。 从当地玩并非所有黑客都在互联网上。例如，它也适用于本地网络。典型的wifis网络，他们有一个相对容易的密码。如果我不知道Wi-Fi的密钥，它可以通过字典强制删除到WPA / WPA2，kali带来着名的rockyou.txt。进入后，扫描显示默认情况下所有设备和典型路由器的经典192.168.0.1/24或192.168.1.1/24。管理员管理员或管理员1234，很少改变它，但如果我仍然没有得到它，当我连接并要求用户名和密码时，它也告诉我品牌和型号。只需在谷歌搜索默认密码，就是这样。访问和控制时，它们通常具有非常基本的配置，因此我们可以正确指定参数，通过DHCP分配IP，扩大范围，DNS，因为我们可以完全控制网络，所以可以更好，更快地帮助网络工作。我们可以看到所有连接的设备，扫描，如果有与SMB或安全VNC团队，默认键连接，即使DVR（服务器监控摄像头）也有保险的默认密钥产品或只是这个地方的名字。如果有共享文件夹，在大多数情况下只能播放音乐，没什么重要的，那就太受欢迎了。所以，你可以把一个邪恶的黑色金属的主题，但当然，我们必须努力多次复制，并把现有的文件是艰苦的，但有趣的名字。我也可以把一个规则，家长控制，我只访问和使用的整个带宽或见好就收某些IP地址我不想要导航（预约DHCP其MAC地址）。 在具有相同SSID但密码不同的管理不善的地方很常见。如我所说，伸出援助之手并没有任何帮助。由于提供Internet的计算机通过网络挂在另一台上，我可以逐个重新配置。如果我不知道管理员的密码，因为他们改变了它，我可以用他们带来的小按钮实际重置设备，只要他们没有看到我并且没有太多人的移动。然后我默认进入并配置它，以便没有人怀疑使用相同的Wifi名称和密码。它并不总是必须为善。我可以将特定计算机的IP指定为DMZ，以便从公共IP外部攻击的所有内容将其重定向到该计算机，或者我只需在我的计算机上安装Web服务器或使用i2p，我不必在防火墙后面，我也可以使用虚拟主机重定向端口，从而从网络上的任何计算机上发布我想要的端口，我可以从路由器外部或DVR或某些端口的游戏，torrent或等等，如果我想，那么我可以攻击他们或从外面访问。学习和玩乐还有很多工作要做。我可以对网络IP进行持续的拒绝服务（DoS），以便计算机的所有者感到沮丧，或者让主路由器强制重置它，当然因为所有的传出流量都会减慢因特网的速度。互联网经历了那里。洪流或其他等等，如果我想，那么我可以攻击他们或从外面访问。学习和玩乐还有很多工作要做。我可以对网络IP进行持续的拒绝服务（DoS），以便计算机的所有者感到沮丧，或者让主路由器强制重置它，当然因为所有的传出流量都会减慢因特网的速度。互联网经历了那里。洪流或其他等等，如果我想，那么我可以攻击他们或从外面访问。学习和玩乐还有很多工作要做。我可以让服务（DoS）攻击不断到IP网络的计算机的所有者被打乱或主路由器强制重置一遍，当然互联网是变慢了，因为出站流量互联网经历了那里。 Android有一个非常有趣的漏洞。 如果有现有的Wifi，例如Drugstore Wifi和我的受害者连接。然后，我可以创建一个完全相同的。当你离开商店时，离开这个地方并跟着它。您的手机将连接到我的AP，是一种天然的功能连接到已保存的搜索Wifis。虽然我不能给或互联网，我可以运行Wireshark的，看看使用喇叭。在希望他们的应用程序，同时连接到我，你会不会使用移动电话公司提供的数据的意义上说，我还没有抓到，直到它离开。最简单的方法打，这是一个麦克唐纳，创建一个AP麦克唐纳免费无键，等待人们来连接，这样可以很方便地有一个良好的天线USB AP（在背包里没人会注意到） ，因为在那里我创建了我的恶意Wifi，并且笔记本电脑的板载我连接到该地方的真实互联网。通过这种方式，我的“客户”会导航而不会注意到任何奇怪的东西。 离开小径 我们所做的一切都会在操作系统，路由器，ISP和我连接的每台服务器中留下痕迹。始终在服务器上，您必须搜索两个文件。access.log和error.log在第一次所有访问中都已解决，因此它具有该名称。另一个文件注册了所有访问错误。例如，dirbuster，sqlmap和hydra等实用程序在进行测试时会产生许多错误，并且随着我们的IP连续重复，该文件会大大增加。出于这个原因，攻击是手动进行的，或者如果使用工具进行攻击，则可以方便地对其进行参数化，以使其尽可能慢地进行。行政事实应该不断检查日志，所以我的工作不应该引起任何怀疑。这就是为什么有些管理员将这两个文件保存在一个单独的服务器上，这使得擦除我们的轨道变得更加困难。这就是为什么我们必须屏蔽我们的IP，在一些VPN，Tor或其他什么，以及更多的一个在另一个之后。连接到VPN，然后通过Tor。但是许多智能管理员会阻止所有Tor的IP，因为Internet上发布了输出节点列表。它让我别无选择，只能随机串行或并行使用VPN或它们的链。每个层都变得更慢，但增加了更多的安全性，甚至到了使用它们而不重复它们的程度。如果您选择公共VPN或支付，这种付款似乎更好，但他们有注册，有些是通过btc付款，这是一个两难的选择。有很快的日本VPN，但在计算机问题上使用俄罗斯或邻国或弱国法律。这就是为什么在新闻中我们总是看到他们据说从俄罗斯攻击美国。除此之外，我相信在当局之前，公司会张开双腿来提供信息。只有VPN允许黑客攻击其条款和条件。位掩码。通常在入侵之后我将其发布在一个不起眼的论坛中，以便每个人都可以输入并因此在日志中生成更多条目并生成更多跟踪以减轻可能的调查。留下其他人的痕迹还有什么好处。 其他黑客我总是对黑客故事感兴趣。它们令人兴奋和创新。用新鲜的想法挑战既定的。我可以从一切中学到一些东西。例如Adrian Lamo，他闯入了最大的安全网络。但他的自我背叛了他。他被称为流浪汉黑客。换句话说，它从网吧，酒吧甚至废弃的建筑物中进行了入侵。这是一个很好的例子，使用互联网不是为了我的活动。他未能成为纽约时报的专家顾问。并且还通过背叛私人曼宁与维基解密的开端。黑客的脆弱性是他自己的自负。DarkDante控制了电话，与收音机相关，因此它被称为保时捷的唯一参赛者，也有助于捕获大量的pederastrians。Gary McKinon在美国宇航局和其他政府机构中获得了非陆地军官档案清单。所有人都赞成追随他对不明飞行物的热情。凯文米特尼克是最着名的，他让我们教。“用户是任何安全系统中最薄弱的环节。” 它是网络钓鱼的基础，如果我们开始分析当前的入侵，系统不再被黑客入侵，而是人们的信任。公司投资于基础设施的安全性，而不是为员工提供培训。如果我喜欢当前的黑客时代，他们会有另一种心态，而不是罪犯的心态。除了一些例外，这个主题的电影是好莱坞的典型垃圾。第一代黑客创建，第二代被摧毁和伪造。目前的人有更多的意识。现在地下的场景结束了。 目前的情景新老黑客现在拥有计算机安全顾问。从法律问题和道德愿景中可以看出一切。有些法律将攻击称为犯罪。整个黑客场景发生了变化。它来自于一个有趣的学习进入过度的地方和大型系统隐藏的顾问，讲师在合同之前进行攻击。黑客本质的味道已经结束了。现在，它有助于互联网2.0中的巨魔，LoT（物联网）的出现，并加强了黑客主义的场景，如匿名。我们甚至可以说自动攻击（美国）最终成为俄罗斯人。希望我们都能理解网络安全意味着什么，人，公司，网络管理员和黑客。 它将继续…… 第3章TorMetal 2018 - TorMental是Team Hacking的出版物 从内到外 入侵并不总是来自外部，也不是来自其他系统。可以安静地对我们安装的系统进行操作。要么评估它的安全性，要么只是练习，学习和学习。有趣的是，你可以从内部审查所有内容，而无需“黑客攻击”任何内容。我是管理员，我可以在内部和即时修改所有内容。进行渗透测试或“Pentest”。我可以直接访问数据库，私人消息，用户表，即使密码在MD5中，我也可以解密它们。使用john或hashcat或hashkiller.co.uk，你就完成了。了解特定用户的活动。有了解密密钥，我可以在他们的facebook，outlook.com和gmail上试试，因为我也有邮件，看看会发生什么。即使这也没必要，因为我可以修改CMS（WordPress）并跳过编码问题并将密码保存为纯文本。它每次都变得越来越难，但它只是跳过加密功能。这就是为什么它非常重要永远不要重复一个键，因为我们不知道我们在哪里注册。有些管理员可以“看到”它。私人消息，用户很少删除它们。因此，建议始终将PGP用于所有类型的通信。我可以监控用户，不满意的人，想要攻击我的系统。我可以添加Last IP表并跟踪它连接的位置。因此，例如分析重复的用户。甚至在连接或思考或我想要的时候设置警报。或者只是修改你的帖子。谁拥有对系统的控制权就可以控制一切。如果我已经控制了其他论坛，我已经被“黑客攻击”，我可以在一个和另一个之间交叉数据。那就是转储（转储）受感染的数据库并进行非常有趣的查询。例如，要查看用户在彼此中的内容，查找相同的密钥，甚至重复IP。SQL就像奇迹一样。在另一个论坛中仍然是SHA-1中的键我可以看到我在我的关键字并在其他系统中尝试它… …宾果游戏。用户总是使用密码几乎是为了同一件事。如果我想更进一步，我可以看到活动很少的用户，登录并向管理员发送消息，然后我删除外发消息。如果您回答我删除收件箱中的邮件，您就完成了。如果原始用户连接，他不应该意识到这一点。如果我想更进一步，我可以在受害用户的另一个论坛上发布一个带有恶意链接的帖子，试图捕获管理员或其他用户的会话cookie。点击链接时要小心。如果发生了某些事情，他们会删除或惩罚该用户。眼睛不会在我身上。如果它是一个旧的论坛，我可以尝试上传一个shell或让管理员欺骗它来执行它。它很少奏效。我记得一个可耻的案例，他们攻击了一个色情网页，有些用户在@ etc.mil或美国官员注册。Mecerido有泄漏（过滤）。 我也可以冒险进入我工作的公司。因为我可以访问网络和一些系统。我获得了大量的支持，这将是一个小问题的研究，而其他人在Facebook上展示他们的生活是多么美好，并且可以用来证明这一点。 普通人对计算事物的简单而无知的观点使我们能够从一个系统转移到另一个系统。但在里面。不要感到惊讶，如果我能做到这一点，我就是一个人，国家安全局怎么办？ ￼ 社会工程 黑客攻击不仅仅是让系统做一些特殊的事情而不是编程。很好的定义 :)系统很难被违反，但不是处理它的人。 这是一个艰难的做法，但同时也很容易。我可以打电话给公司询问某个地区，提出索赔要求并要求提供更多信息，他们会告诉我，你必须有这个数字，证明，等等。同一个受害者正在指导我违反它。我可以请你寄给我一份文件或发给我一份。我可以分析他们的元数据，发送带有javascripts的HTML格式的电子邮件来查找内容。发送链接或受感染的文件，而我们在通话时没有人会过多关注安全性。但这对于防病毒来说更难。总是有管理员，懒惰，准备不足和收入不高，所以他们会依赖于那些工作。这是超级犯罪。模拟员工并致电系统区域以请求重置密码。内部系统总是比外部系统具有更少的保护。建筑维护区域，很少了解计算机，如果我有实习生，我可以让我通过其中一个系统，以前发现。输入员工的网络邮件。人力资源领域充满了问题，我所画的事实是一个非常大的进步。我打电话给某人特别送货，并用一些姓氏字母让我困惑，我的受害者肯定会纠正我，并会在没有意识到的情况下给我更多信息。人力资源领域充满了问题，我所画的事实是一个非常大的进步。我打电话给某人特别送货，并用一些姓氏字母让我困惑，我的受害者肯定会纠正我，并会在没有意识到的情况下给我更多信息。人力资源领域充满了问题，我所画的事实是一个非常大的进步。我打电话给某人特别送货，并用一些姓氏字母让我困惑，我的受害者肯定会纠正我，并会在没有意识到的情况下给我更多信息。谁说Hacking是用电脑完成的？系统很难被破解，但不是处理它的人。易受攻击的是那里。因为最终用户点击了他不应该去的地方，他的信任被欺骗了。 ￼ 感觉力量 当我进入一个系统时，我感觉到了上帝，哈哈。虽然实际上它是一个对“小弟弟”有自命不凡的语言，但这种感觉是不可阻挡的。当我看到系统管理密钥正常工作时，我的胸部肿胀，心脏停止。在让我失望之后，有些目标没有任何用处。这就像一个魔术，在你知道它是如何工作之后，你会失去乐趣。但是有一所大学改变了我的呼吸。每小时和每小时导航每个文本框，分析所有表格（POST）和GET测试所有基本注射’或’1’=’哈哈’1’=’1’-1 - ‘“\\等我找到了一个部分新的，“弱点”，当测试注入时，SQL失败告诉我mysql的典型错误。我准备好了，我知道在哪里注入。测试-1 + union + select + 1.2–所有这些都是手工繁琐的和焦虑现在杀了我，所以我给它参数后，我使用我最喜欢的工具，sqlmap，–random-agent –tor –threads = 2 –time-sec = 10 - delay = 10因此它的工作非常缓慢，因此不会引起怀疑。你的WAF仍然可以实现，所以我需要用–tamper charencode，base64encode，multiplespaces，space2comment只用两个来欺骗你。使用详细模式，您可以看到该工具如何工作并知道它开始失败的位置，这意味着另一方面WAF正在排斥我的攻击，因此我必须停止，更正参数并重新启动命令。这会产生焦虑和压力，因为即使VPN可以看到流量，所以我也必须考虑到这一点，或者只是通过tor释放它，但即使WAF阻止我，我也必须重新启动tor并重新启动一切试。更换螺纹，夯锤或注射和注射之间的时间。这一切都让这段时间过得非常快，但这种情绪让我不能停下来。咖啡帮助我冷静下来，尝试尝试，直到他妈的sqlmap通过WAF，它可以在没有意识到的情况下进行注射，直到结果发现漏洞。这种情绪会带来快乐的飞跃，是的！它很脆弱。好，但很平静，我只有进入的通道门。在再次调整工具的参数之后，我请你带给我所有的数据库–dbs，和uff，它们很多，当然我看到他们有几个项目，一个图书馆，其他门户网站，它是一所大学。将过多数据库放在同一数据库引擎下的致命错误。对于搜索中的文本框，我最终会访问我工作的特定页面之外的所有可用信息。我选择了一个数据库，然后带上你的工作簿 - 表。还是有太多了。已经凌晨3点了，我的收获很少。当管理员在他的床上睡觉时，有人潜入他的系统。 我也看到PhpBB数据库，WordPress，都是混合的。这样做的人并不十分清楚他在做什么。那么现在我把phpbb_users和wp_users的经典表首先带到他们的列–columns，我选择我想要的那些，最后是dumpeo –dump。最有趣的是所有数据库的邮件用户传递。学生或老师的桌子对我不感兴趣，我会变大。不要伤害，但要尽可能多的伤害。如果我想找一个特定的人，我只是喜欢和去。这是黎明，我还在这里和那里盘旋。直到找到一个管理员委员会。我喝了最后一杯咖啡，sindo是时候吃早餐了，虽然我连续吃了很多次早餐。这个表我可以完全转储，因为它总是很小，只有其他一些行。准备好所有这些时间总结为最后输入我按下。如果一切顺利……并且…在我面前闪耀一行。管理员用户密码admin ** sqlmap有一个内部字典试图解密密钥。不过，我复制它并同时将john和hashcat放在一起工作。已经是早上7点，时间流逝，我不能再忍受了。焦虑让我痛苦，我在网上词典中寻找它。有人必须完成并给我我想要的东西。最后，使用的密码不值得一个好的管理员的位置。这是一种耻辱，但我的主要目标是实现的。现在我可以去大学了。总是在一切，前后都有。首先是要知道我是否能够实现它。后者可能是我成功了，或者最可靠的是它没有发生，我充满了不满和沮丧。我的成功率很低，但是当它给出时……这是一种非常奇怪的快乐，因为普通人没有人能理解它。 ￼ 革命现在开始了 在一边和另一边旋转了这么多。在我看来，我学到了许多有趣而准确的东西，以逃避政府和大公司的间谍活动。我甚至敢说，完全是匿名的。但这是一把双刃剑，因为有人说不可能是匿名的，我说是的。演示可能导致人们误解并将其用于选择性活动。从这个意义上说，我可以鼓励人们违法。但这不是我的目标，虽然我觉得我必须这样做。让每个人在互联网上自由地处理自己就像一把锤子，可以用于可重复性或者为了伤害。像刀子一样，本身并不坏，它没有伤害，但一切都将取决于使用它的人和它的意图。我觉得我有使命，有使命的帮助。展示政府和大公司所表现出的不同现实。我的目标是让我的想法浮现，出现并帮助创造一种新的集体意识。看待事物的另一种方式。挑战既定的，简单地质疑它而不破坏任何东西。革命没有在街头表现出来，革命是知识分子，现在开始。 ￼ 它将继续…… 第4章 TorMetal 2018 - TorMental是Team Hacking的出版物 黑客团队的历史故事以他的名字开头，作为一个群体。但最重要的是，这个名称被认为是容易找到的东西，并且在许多可能出现的结果中被混淆。有时为了隐藏某些东西，你必须简单地展示自己。这个名字的灵感来自意大利安全公司Hacking Team，该公司被计算机安全研究员Phineas Fisher攻击。我很喜欢它，因为它是逐渐参与的，一点一点地推进，所有这一切都来自于在DW（深度网络）中购买的0day。阅读他如何做的步骤是非常令人兴奋和有趣的。只有对我来说，我想把这个名字给予Hacking团队，并将骑士变成knigth，这对于Hacking团队而言。一个愚蠢的问题，因为这听起来像英文错误。或者没有直接的。这个想法是使用一个常用词，绅士用英语，并做一些事情，使它成为我的。像H4ck3r8这样的事情已经发生在我身上。因为那个缺口，因为我的导师，我的第一个跟随的是某个knightX谁拥有一个geocities网站。美好的时光。为了纪念他。虽然我已经使用了几个昵称，但至少为此我们将留下一些绰号。好吧，在我在DW的时候，我厌倦了在论坛上发帖，以至于他们以后就会消失，而且入侵，数据库等都丢失了。我将永远记得发表他的“本周污损”的干相小海湾，他们都是灵魂。但最终，论坛死了，我的所有帖子也都消失了。所以我决定创造自己的空间，独立于一切。发布并能够控制我发布的所有内容。我总是很容易访问数据库，所以我只从低名网站发布，我不想遇到麻烦，只是展示我的技能，并能够在环境中遇到更多更高级别的人。有趣的是，我访问了一些我从未想过可以进入的地方。它对可能发生的事情感到害怕，这就是为什么它就在那里，我不会在那些情况下重复它。很多次偶然。例如，访问数据库时未更新的旧站点我发现存在更多数据库，所有数据库都在同一引擎（数据库服务器）下。然后，通过页面中的漏洞，它最终会破坏该完整服务器的所有数据库。所以可能会有更多的公司，学院等 除了拥有一个用户，您还可以平等地访问所有内容。回到团队的主题，他们似乎感兴趣，但他们离开，其他人来等等。他们贡献了一些东西，他们采取了一些东西，然后他们完全消失了。我的梦想是你可以建立一个联盟，一个讨论各种问题，信息技术，安全，政治和时事的团队。有趣的事情是一起完成的，而不是分开的。总是整体不仅仅是各部分的总和。有助于网络的自由，而不是其中的滥用。我认为，如果所有人共享黑客攻击的网站或系统，您可以跨越所有信息并达到一些重要的目标。有点邪恶，但这有助于人们更好地生活。大公司对地球不感兴趣，更不用说它的居民和资源了。想法永远是好的，只有人们执行它们并且它们是腐败的。所有人都是在没有邪恶的情况下出生的，但在社会中发生了一些自私的事 我们是社会的敌人。 新社区见到我的新邻居的最好方法是破解他们的wifis，因为付出了丰富的东西并侵入我的私人财产？看看他们连接了哪些设备，大部分是移动设备，分析他们的流量只是为了看垃圾，事情变得不重要。失去时间 现在有很好的覆盖范围的wifis中继器，例如室外，但是其他设备将所有这些WAN连接连接到一个。因为如果我可以使用vaias，我只使用破解的wifi。我也可以选择离我最近的位置。这更有助于匿名。除非网络瘫痪，请关注另一个网络并继续。我也可以按照我的方式旋转它们。一切都是如此简单，比如在角落商店里喝咖啡，询问你的密码，然后以放大的方式从我的地方使用它。即便如此，凭借这些技术，他们已经陷入困境，如果我们参与非法活动，我们将以严重的方式结束，这只是一个时间问题。你在互联网上所做的一切都可以用来对付你。使用非专有的wifi不是问题，因为它是统一费率，但是分析您的流量或尝试进入您的计算机，如果它是入侵，还有更多从计算机获取数据。 匿名我花时间追逐匿名的人。他们有页面，但大多数都已关闭或过时。谈论他们所说的不再存在。只有关于这个主题的无信息文章。很多虚假信息。直到有一天我给他们，他们真的在一个非常简单的地方。www.anonops.com和几个人一起说英语，我来到一个管理员，他问我几个问题，我通过了所有测试，但不是最后一个。什么是匿名？我的所有答案都没有给出密钥。而这个角色告诉我，这是一个想法。但是，就像所有的想法一样，它是由那些尊严很容易被打破的人管理的，我们都有代价。我的对话者说， 任何人都可以匿名，只要他们遵循他们的理想。但实际情况是，许多操作都是代表这个小组完成的。但这个想法实现了吗？我认为一切都是垃圾。很多东西都是垃圾。谁是匿名的领导者？没有人回答我，同时也是每个人。#op在一个小组中决定，每个人都平等参与。但是，在youtube上发布的大多数视频都是由老鼠制作的。使用Loquendo非常容易，在背景中使用面具打手势的典型角色。没有人看到他的嘴，因此很容易。所以任何人都可以进行#operation并将其归于Anonymous。这个想法很好，因为它超越了所有地理问题，语言，种族，宗教等。它们无处不在。这很棒，因为有很多人在同名的情况下打击不公正。这听起来不错，但也很吓人。因为有人可能会使用他的名字做错或者说是好的，甚至可能破坏页面并说它是匿名的。这是好事还是坏事？有人有什么好处？善恶？与新闻一样，他们抓获了10名匿名成员。他们真的是黑客？他们来自匿名？他们遵循了一些理想？或者他们是否将其判定为Anonymous，以便突袭听起来会更成功？因此，作为一个简单的计算机罪犯，会徽和流行的声音更严重。历史是由那些赢了，警察赢了的人写的。所以这意味着还有另一个故事，但是，我们无法知道。但小报出版社，博主，youtubers等的所有失真。谁阻止同一当局进行攻击并将其授予Anonymous，所以这个话题在整个互联网上都是病毒式的。匿名的想法虽然好但很危险。作为匿名，一切都是允许的。 托尔令人印象深刻的是可以完成的事情。例如，使用Tor，您可以指定仅使用特定输出节点。优选RU，CH等 据说美国国家安全局已经采取了许多出口节点，可能来自美国领土，机器人先生从该神话开始。使用特定输出可提供一些额外的安全性。我也可以运行Tor的几个实例，所以不要使用Tor，我可以一次使用Tor几次。这很好，因为使用网络的http / https / socks代理是没有意义的，因为它们受到干扰而且不适用于攻击，因为它们会在短时间内免费阻止我。但我可以使用我自己的“自己的”自定义代理，使用Tor来实现它。我可以根据需要多次复制tor文件夹并正确分配权限我可以进行配置，以便每个实例为俄罗斯留下一个，为中国留下另一个等等。当然我也要重新分配端口，9050,9051,9052等。在此之后，我配置polipo，一个很好的代理，保持我的所有导航，理想的加速DW的页面，privoxy添加一些安全问题，我甚至ping，traceroute和DNS查询使一切都四处走动。我把这个系统的代理作为127.0.0.1:8118的代理，然后我转向privoxy，在privoxy跳到polipo之后，在后者转到Tor的实例。虽然我无法真正看到，但我可以将代理链与TOR实例一起使用，并看到当您进入页面时，一切都在不同的地方。也就是说，html将其下载为Tor的实例，对于另一个人而言，这是一个令人难以置信的页面，其中的条目被打破，以便每个partcita通过一个不同的出口节点。哇。魔术？有了etherape它是一个实时网络分析仪的图形模式可以看出。 我要走了自从我感到困惑以来已经很久了。当我在做什么和做什么时达到极限，因为我总是做同样的事情。我想我有可能帮助改变一切。但我也感到愚蠢。我想发表我所拥有的一切，但我担心一切都会反对我。我已经有足够的“地方”了。我还想带领一个庞大的人员和服务器团队。但人们要么是自私的，要么是无知的，要么害怕可能发生在他们身上的事情。但将多才多艺的跨学科力量组合在一起会很棒。让事情真的变得严肃起来。 一切都是孤独的道路，现在是时候曝光了，但我想我会对自己的寂寞感到更加沮丧。我厌倦了和自己说话。这不再起作用，它对我没有帮助。不过，我还会继续…… TorMetal 2018 - TorMental是Team Hacking的出版物","categories":[],"tags":[]},{"title":"关于网络匿名","slug":"网络匿名","date":"2018-07-28T13:39:34.000Z","updated":"2018-07-30T12:28:44.000Z","comments":true,"path":"2018/07/28/网络匿名/","link":"","permalink":"http://zero-mk.github.io/2018/07/28/网络匿名/","excerpt":"","text":"数字抵制政府和企业的间谍活动在暗网翻出来的，机翻的有点那个啥看看就就，非本人原创 我们的目标：本指南假装教授安全的冲浪。它不会假装鼓励犯罪。这是一个概念上的指导。个人安全手册。知道一点，它永远不会伤害。 我们认为，言论自由必须是一项真正的权利。匿名和隐私是一种保证。不幸的是，有人利用这一点来做恶。这个想法是用来对付政府和大公司。这是我们的目标。黑客行为。争取我们在网络中的权利。 它们不会给我们上网，它是一种抑制和观察的工具。看见一切的眼睛，1984年的“老大哥”。这是一个新的互动数字“圣经”，它自动出现在我们面前。“religosidad”现在发挥政府的作用。间谍活动是在没有被人看到的情况下进行的。他们还将人们的私生活变成了公共事物。比如Facebook。了解人们的品味和欲望。比如谷歌。 不仅如此，他们发送给我们并用广告轰炸我们，建立没有感官的刻板印象的目标。 计算机安全不仅仅是安装TOR浏览器。这是一个对技术态度，理解它如何运作的问题，因为它们可能会随着时间的推移而发生变化，但如果我们看到信息与个人安全没有改变，我们将一如既往地保持脆弱性。 本指南旨在证明您可以在网络上拥有匿名配置文件。我们将从硬件转向软件再到我们的习惯。 硬件/软件级别：首先，您应该为您的匿名任务获得一台笔记本电脑。你必须得到它的二手。如果它是新的或使用无关紧要，您的购买交易无需注册。尝试成为最常见，没有奢侈或浮华的计算机，可以让你识别。什么都不应该与你联系。从来没有，在任何情况下都不应该混合你的现实生活。你在这做什么应该留在这里。照顾好您的匿名个人资料。那么你不应该检查你的Facebook，或你的Gmail等。在这个团队中。 将密码放在开头，然后放入设置。打开笔记本电脑时，您应该要求输入密码。磁盘必须由您格式化，安装您认为方便的操作系统，但即使这样，也要加密磁盘，pendrives以及您使用的所有内容。操作系统总是要求输入密码，甚至在屏幕保护程序后要求输入密码。不言而喻，它必须是一个强大的密码。团队名称必须尽可能标准。团队总是不得不带着你或者在一个隐蔽的地方，远离你。这取决于你做了什么。 改变团队的MAC，如果你正在读这个，你必须知道它是什么。盖上相机和麦克风。仍然避免安装驱动程序。据斯诺登说，美国国家安全局可以进入，直到仍然关闭。除非您的VPN / Tor方案为您提供安全保护，否则不应使用此设备连接到Internet连接。此外，您不应该在此计算机上检查您喜欢的页面。同样，如果您希望匿名配置文件与您的真实生活档案保持匿名，则不应混淆您的匿名配置文件。从来没有。 您最后必须使用Tor浏览器完成导航，但如果您需要使用通用浏览器，通过VPN，或代理socks5或Tor，您必须在隐身模式下使用它。虽然此模式会留下您使用互联网上的常用导航生成的相同跟踪，但隐身模式不会生成本地跟踪，Cookie，历史记录等。 无论您使用何种操作系统，它都应该是英文版，其时间设置与您的不同。安装了更新的防病毒软件，如果可能的话安装防火墙和防恶魔软件。随着操作系统，它必须更新。安装必不可少的软件，并尽可能减少配置，删除所有不使用的软件，当然这也必须更新。在浏览器中禁用“记住历史记录”。最好使用FireFox或其他开源，即使这样，也始终以隐身模式导航。退出浏览器时，切勿使用密码提醒并删除整个历史记录。如果您使用linux，请禁用bash历史记录，如果您使用Windows，则有许多软件可用于禁用它带来的间谍选项。在浏览器中安装附加组件，在任何地方安装https，而不是javascript，广告拦截器和随机代理。 此外，您不必拥有可识别您身份的用户名和密码。它不必涉及个人品味，标题，身体特征，更不用说你的名字。顺便说一句，您使用的密码必须是唯一的，并且对于您输入的所有系统都不可重复。此外，它不应该有任何逻辑。例如，Facebook密钥不能fuck.facebook Gmail fuck.gmail等。如果你有逻辑，有人可以猜测甚至猜你的其他键。将替代搜索引擎用于Google。 使用虚拟机，可以帮助我们，无论是测试来历不明的程序Opara只是上网冲浪有使后VM被删除或恢复回来，留下的各种证据。据CHEMA阿隆索，有恶意软件，可以“跳”虚拟机的主机系统。 Internet连接级别切勿使用自己的Internet连接。使用破裂的wifis（这是非法的）或网吧，图书馆，公共场所。 例如，即使您可以使用USB AP连接到Wifis，它也是理想的选择，因为如果您检测到网络中存在的入侵，您可以快速丢弃该设备。使用VPN，当然还有TOR。有几个连接方案并交替使用它们。仍然尝试每隔一段时间使用新的VPN。 禁用我们的路由器到Internet的日志记录。从其他wifis路由器到我们连接的地方，如果我们能做到的话。ISP可以记录我们的流量，使用https，它不再是保证。仅这一点就可以实现隐私，所以你不知道发生了什么，但是如果你知道我们连接到谷歌那么。VPN的使用将避免ISP，但VPN的人知道我们连接并且有流量，但他们无法破译它。VPN，取决于它是否付费，取决于它所在的国家/地区。它可能记录也可能不记录我们的行为。真的很难知道它。阅读您的隐私政策。谨防美国VPN。连接到网络的所有设备都有一个IP，我们使用的服务越多，无论是VPN，Tor，我们都会添加层，这会使我们更难以联系到我们。作为回报，牺牲速度但获得安全。 导航级别使用Proxies Web并不是一项艰巨的任务，无论代理记录我们的操作多少。例如，它用于测试另一个用户，该用户与我们正在使用的用户不同，并且不会保留在使用相同IP输入到两个不同帐户的系统中。有些系统通过IP进行限制以进行查询。一个简单的Web代理可以跳过这个障碍。 像Tails这样的现场CD可以很好地解决所有问题。但请记住，绝对没有本地记录，但你在网络上做什么。 另外请记住，使用javascript，flash等，您可以找到您的IP，无论您采用的所有匿名超级措施如何。我们自己是最脆弱的一点。 安全策略级别这是最困难的级别。改变习惯，或有两个习惯。一个正常的互联网和另一平行于暗网维权的作用。为了谁捉住了，已经这样做了，他们通过写如何，甚至你的浏览行为，相同的连接方案和重复页面之间的导航最，先进入一本刊物，那么邮件，然后和好。小心点 一切都可以找到你。阅读VPN，代理等的隐私政策。隐私政策。我认为，如果我们读coinciencia，从来没有什么更多的，我们会在网上注册。怎么可能是谷歌，Facebook等 自由吗？不要谈论更多，并照顾所有充分说明的事情。所有被说和“写”的东西都可以用来对付我们。 总是想象有人在看着我们。让我们按照那样做。拥有所需的安全级别是我们的责任。有匿名和一些临时邮件服务。根据我们开发的活动，它可以是一个很好的资源。 请记住，计算机专家基于痕迹，日志和记录的任何内容来指责我们。其余的是逻辑问题而不是技术问题。你不应该发表评论，说明某人可以认识到你的个性，你的意见，打字错误，西班牙语的当地方言等。小心你的写作或写作方式。所有这些问题都可以将您与现实生活情况联系起来。尽可能少地参与。即使种植虚假信息，也会生成与您无关的踪迹。永远不要告诉别人你做了什么。这可能会对你不利。 最后两个问题1.如果我们的电脑或手机落入当局的手中，会发生什么？那不一定会发生。但是如果我们抢劫或丢失一些设备会发生什么。我们在那里拥有什么私人物品，我们不想落入坏人之手？3.如果我们接近并且我们认为我们已经改变了互联网上的某些页面，会发生什么。我们准备好了吗？我们的运营应始终基于之前的问题。 除了技术观点之外，秘诀就是要有多种习惯，好像我们有多重性格一样。协会的概念非常重要。我们不应该出于任何原因将这两个人物联系起来，既不是真实的，也不是虚拟的，反之亦然。这是每个人都失败并被抓住的地方。封闭的嘴巴最终成为匿名的最佳工具。自我是你的主要敌人。 对于一个自由思想的网络。知识分子革命现在开始了。 开放获取游击队的宣言摘录我们需要获取信息，无论它存储在何处，制作我们的副本并与世界分享。我们需要将没有复制权的内容添加到此文件中。我们需要购买秘密数据库并将其放在网上。我们需要下载科学期刊并将其上传到文件共享网络。我们需要打一场游击队进行开放存取。 如果我们足够，在世界各地，我们不仅会发出反对知识私有化的强烈信息 - 我们将使它成为过去。你打算加入我们吗？ Aaron Swartz2008年7月，Eremo，意大利","categories":[],"tags":[]}]}